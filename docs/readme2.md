# Oluja Engine

## Overview

Oluja Engine is a modern, extensible, and performant 2D slot machine engine built using PixiJS v8 and GSAP v3 for hardware-accelerated rendering and smooth animations. It's designed with a modular architecture to facilitate the creation of diverse and engaging slot games for web platforms.

The engine handles core slot functionalities including reel spinning, symbol rendering, configurable game settings, payline evaluation, win presentation, and basic features like Free Spins, Autoplay, and Turbo Mode. It utilizes Vite for an efficient development workflow.

**Note:** While currently featuring client-side logic for demonstration, the engine's architecture is designed with the intention of integrating a server-authoritative backend for critical functions like RNG (Random Number Generation), win validation, and persistent state management in a production environment.

## Core Technologies

* **Rendering:** [PixiJS](https://pixijs.com/) (v8.x) - Fast, hardware-accelerated 2D rendering library.
* **Animation:** [GSAP (GreenSock Animation Platform)](https://greensock.com/gsap/) (v3.x) - Professional animation library for smooth tweens and complex timelines.
* **Language:** JavaScript (ES Modules)
* **Build Tool / Dev Server:** [Vite](https://vitejs.dev/) - Fast frontend tooling.
* **Markup / Styling:** HTML5 / CSS3

## Project Structure

```
.
├── dist/                  # Production build output (generated by `npm run build`)
├── docs/                  # Project documentation (vision, guides, etc.)
│   ├── project.md         # Detailed project vision & technical plan ("Project Phoenix")
│   ├── README.md          # Code-level documentation overview
│   ├── IMPROVEMENTS.md    # Ideas for future enhancements
│   └── CustomAnimationGuide.md # Guide for adding symbol animations
├── public/                # Static assets (e.g., audio, fonts - copied as-is)
│   └── assets/
│       ├── audio/         # Sound effects and music files
│       ├── control/       # SVG icons for UI buttons
│       ├── fonts/         # Font files
│       └── images/        # Symbol textures, backgrounds
├── src/                   # Main source code directory
│   ├── config/            # Configuration files (game settings, symbols, paylines, reels)
│   │   ├── animationSettings.js
│   │   ├── gameSettings.js
│   │   ├── paylines.js
│   │   ├── reelStrips.js
│   │   └── symbolDefinitions.js
│   ├── core/              # Core engine logic (Game, Reel, State, Symbol)
│   │   ├── Game.js        # Main game orchestrator
│   │   ├── GameState.js   # Central state management
│   │   ├── Reel.js        # Individual reel logic and animation
│   │   └── Symbol.js      # Symbol rendering and representation (PIXI.Sprite)
│   ├── features/          # Specific game features (Win Eval, FS, Autoplay, Animations)
│   │   ├── Animations.js  # Win presentation, particles, symbol animation registry
│   │   ├── AnimationDemo.js # Example usage of custom symbol animations
│   │   ├── Autoplay.js
│   │   ├── FreeSpins.js
│   │   ├── PaylineGraphics.js
│   │   ├── SpriteSheetAnimations.js # Helpers for sprite sheet anims
│   │   ├── TurboMode.js
│   │   └── WinEvaluation.js
│   ├── styles/            # CSS styles
│   │   └── main.css
│   ├── ui/                # User Interface components and logic
│   │   ├── ButtonFactory.js # Creates reusable button components
│   │   ├── ButtonHandlers.js # Event handlers for button clicks
│   │   ├── DebugPanel.js    # Optional panel for development debugging
│   │   ├── InfoOverlay.js   # Manages the external HTML info display
│   │   ├── Notifications.js # Handles overlay messages and flashes
│   │   └── UIManager.js     # Manages PIXI Text displays and button states
│   ├── utils/             # Utility functions
│   │   └── helpers.js
│   └── main.js            # Application entry point
├── index.html             # Main HTML file
├── package.json           # Project dependencies and scripts
└── README.md              # This file
```

## Core Concepts & Workflow

### 1. Initialization (`main.js` -> `Game.js::init`)

* `main.js` waits for the DOM, then creates and initializes a `Game` instance.
* `Game.js::init`:
    * Sets up the `PIXI.Application`.
    * Uses `PIXI.Assets` to load necessary textures (symbols from `config/symbolDefinitions.js`, background), SVG icons (`ui/ButtonFactory.js::loadButtonAssets`), and potentially audio/fonts.
    * Creates main `PIXI.Container` layers (background, reels, UI, win lines, overlays, particles).
    * Initializes core modules (`GameState`, `UIManager`, `SoundManager`, feature modules) passing necessary references (e.g., PIXI App, containers).
    * Creates `Reel` instances based on `config/reelStrips.js`.
    * Sets up the UI elements (buttons, text displays) using `ButtonFactory` and `UIManager`.
    * Applies a mask to the `reelContainer` to show only the visible symbol area.
    * Initializes the external HTML `InfoOverlay`.
    * Initializes the `DebugPanel`.
    * Starts the PixiJS ticker, calling `Game.js::update` on each frame.

### 2. Game Loop (`Game.js::update`)

* Called on every frame by `app.ticker`.
* Calculates delta time.
* Updates each `Reel` instance (`Reel.update`), checking if any are still moving.
* Updates ongoing animations like particle effects (`Animations.updateParticles`).
* Updates the Free Spins indicator UI (`Game.js::updateFreeSpinsIndicator`).
* Checks if all reels have stopped moving (`anyReelMoving === false`) while the game was in a `isSpinning` state. If so, it calls `Game.handleSpinEnd`.

### 3. State Management (`GameState.js`)

* Exports a central `state` object holding all mutable game data (balance, bet, win, spinning status, feature flags).
* `initGameState()` resets the state to default values.
* `updateState(updates)` function merges partial updates into the main state object. This is the **primary way** state should be modified throughout the application to ensure consistency.
* UI elements (`UIManager`) and feature logic observe this state to update themselves.

### 4. Configuration (`config/`)

* This directory is crucial for defining game specifics without changing core engine code.
* `gameSettings.js`: Dimensions, number of reels, symbol sizes, bet levels, feature flags (e.g., `ENABLE_FREE_SPINS`), background settings.
* `symbolDefinitions.js`: Defines each symbol's ID (used for texture loading), and payout table (`PAYTABLE`).
* `reelStrips.js`: Defines the sequence of symbol IDs for each reel.
* `paylines.js`: Defines the coordinates for each winning line.
* `animationSettings.js`: Defines speeds, durations, and timings for reel spins, stops, and win animations (normal and turbo modes).

### 5. Rendering (`Symbol.js`, `Reel.js`, PixiJS)

* Symbols are represented by the `SymbolSprite` class (`core/Symbol.js`), which extends `PIXI.Sprite`.
* Symbol textures are loaded based on `symbolId` during `Game.init`.
* `Reel.js` manages a collection of `SymbolSprite` instances.
* `Reel.alignReelSymbols()` dynamically updates the `texture` and `y` position of the sprites within the reel container based on the reel's current `position` on its virtual strip, creating the illusion of an infinite spinning reel.
* A `PIXI.Graphics` mask is applied to the `reelContainer` to hide symbols outside the visible play area.

### 6. Reel Mechanics (`Reel.js`)

* **States:** Manages its state (`idle`, `accelerating`, `spinning`, `tweeningStop`, `stopped`).
* **Spinning:** In `accelerating` and `spinning` states, `position` is updated based on speed and delta time. Visual effects (blur, shimmer) are applied based on speed.
* **Stopping:**
    * `Game.startSpinLoop` calculates an absolute `targetStopTime` for each reel based on base duration and stagger (`animationSettings.js`).
    * `Reel.scheduleStop(targetStopTime)` stores this time.
    * In `Reel.update`, when `now >= targetStopTime - stopTweenDuration`, the state changes to `tweeningStop`.
    * A **GSAP tween** is created to animate the `reel.position` smoothly from its current value to the final `stopIndex` over `stopTweenDuration`. GSAP's easing functions (`quad.out`) are used.
    * The tween's `onUpdate` calls `alignReelSymbols` and fades out spin effects.
    * The tween's `onComplete` sets the state to `stopped`, ensures the exact final position, and cleans up effects.

### 7. Spin Cycle (Client-Centric View - *Server integration pending*)

1.  **Click Spin:** User clicks the spin button -> `ButtonHandlers.startSpin`.
2.  **Checks:** Basic checks (already spinning?, sufficient balance?).
3.  **State Update:** `GameState` updated (`isSpinning: true`, deduct bet, reset win). UI updated (`UIManager.updateDisplays`, `setButtonsEnabled(false)`).
4.  **Initiate Spin:** `Game.startSpinLoop` is called.
5.  **Schedule Stops:** `startSpinLoop` iterates through reels, calls `reel.startSpinning()` (sets state to 'accelerating', applies effects), and calculates the `targetStopTime` for each reel using configured durations and stagger (`animationSettings.js`). It calls `reel.scheduleStop(targetStopTime)`. *(Future: `stopIndex` for each reel will come from the server result)*.
6.  **Reels Update:** `Game.update` loop calls `reel.update` for each reel.
    * Reels accelerate, spin at max speed, update symbol positions (`alignReelSymbols`).
    * When `now` approaches `targetStopTime`, the reel enters `tweeningStop` state.
    * GSAP tween animates `reel.position` to the final `stopIndex`.
    * Tween `onComplete` sets state to `stopped`.
7.  **Spin End Detection:** `Game.update` detects `isSpinning` is true but `anyReelMoving` is false -> calls `Game.handleSpinEnd`.
8.  **Handle Spin End:** `handleSpinEnd` sets `isTransitioning: true`, waits briefly, then calls `WinEvaluation.evaluateWin`.
9.  **Win Evaluation:** *(Future: Uses server win data)* Calculates win, updates `GameState` (`lastTotalWin`, `balance`).
10. **Win Presentation:** Triggers `PaylineGraphics`, `Animations` (rollup, symbol anims, particles).
11. **Next Action:** `handleSpinEnd` checks `GameState` (Free Spins, Autoplay) and either triggers the next automatic spin (`handleFreeSpinEnd`, `handleAutoplayNextSpin`) or re-enables controls (`setButtonsEnabled(true)`).

### 8. Win Evaluation & Presentation (`WinEvaluation.js`, `PaylineGraphics.js`, `Animations.js`)

* *(Future: Driven by server response)*.
* *(Current):* `evaluateWin` gets the visible symbol grid (`getResultsGrid`), compares symbols along `PAYLINES` against the `PAYTABLE`, calculates wins, and checks for scatters.
* Updates `GameState` (`lastTotalWin`, `winningLinesInfo`).
* If win > 0:
    * Calls `PaylineGraphics.drawWinLines`.
    * Calls `Animations.playWinAnimations` (triggers rollup, checks for Big/Mega Win overlays, triggers particles).
    * Calls `Animations.animateWinningSymbols` (triggers animations on the specific winning symbols using GSAP and the custom animation registry).
* Checks scatter count to potentially trigger `FreeSpins.enterFreeSpins`.

### 9. UI System (`ui/`)

* `ButtonFactory` creates standardized interactive buttons, handling different states (idle, hover, down, active) and using GSAP for press/release animations. Supports loaded SVG icons or drawn graphics.
* `UIManager` creates and manages core `PIXI.Text` displays (Balance, Bet, Win, Win Rollup). `updateDisplays` function updates text content based on `GameState`. `setButtonsEnabled` toggles interactivity and alpha. It also updates visual states for toggle buttons (Autoplay, Turbo).
* `ButtonHandlers` contains the logic executed on button clicks, updating state and calling relevant `Game` or feature functions.
* `Notifications` provides functions to show temporary centered messages (using GSAP fades) and flash elements.
* `InfoOverlay` controls the content of the external HTML `<div>` for status messages.
* `DebugPanel` creates an optional overlay with controls for development/testing.

### 10. Feature Modules (`features/`)

* Modules like `FreeSpins.js`, `Autoplay.js`, `TurboMode.js` encapsulate the logic for specific features.
* They interact with `GameState` to read/write their relevant state variables.
* They are typically initiated from `Game.js` and provide functions called during the game flow (e.g., `enterFreeSpins`, `handleAutoplayNextSpin`, `applyTurboSettings`).
* `FreeSpins.js`, for example, handles the entire FS lifecycle: entry animation/message, starting spins automatically, applying multipliers (*future: based on server*), tracking remaining spins/win, and handling the exit sequence.

### 11. Custom Animations (`Animations.js`, `AnimationDemo.js`)

* `Animations.js` contains a `symbolAnimations` Map (registry).
* `registerSymbolAnimation(symbolId, animationFn)` allows associating a specific function with a symbol ID.
* The `animationFn` receives the `SymbolSprite` instance, a base GSAP `timeline`, and a `config` object (durations, original values). It can add custom GSAP tweens or other effects to the timeline.
* `animateWinningSymbols` checks this registry; if a custom function exists for a winning symbol, it's called; otherwise, a default animation is applied.
* `AnimationDemo.js` shows examples of how to register different types of custom animations (code-based, filter-based).
* `SpriteSheetAnimations.js` provides helpers for loading and using frame-by-frame animations from sprite sheets (intended to be used with the registry).

### 12. Asset Loading (`Game.js::init`, `PIXI.Assets`)

* `PIXI.Assets` is used for loading all necessary visual assets upfront (textures, SVGs).
* Symbol textures are loaded based on IDs defined in `symbolDefinitions.js`.
* Button SVGs are loaded via `loadButtonAssets`.
* Background image is loaded by alias.
* *(Future: Audio assets will likely be loaded via `PIXI.Assets` or the chosen audio library's loader in `SoundManager.js`)*.

## Getting Started

1.  **Prerequisites:** Ensure [Node.js](https://nodejs.org/) (which includes npm) is installed.
2.  **Clone Repository:** `git clone <repository-url>`
3.  **Navigate:** `cd oluja-engine`
4.  **Install Dependencies:** `npm install`
5.  **Run Development Server:** `npm run dev`
6.  **Open Browser:** Navigate to the local URL provided by Vite (e.g., `http://localhost:5173`).

## Development

* **Dev Server:** `npm run dev` starts the Vite development server with Hot Module Replacement (HMR) for rapid development.
* **Build:** `npm run build` creates an optimized production build in the `dist/` folder.
* **Preview:** `npm run preview` serves the production build locally for testing.
* **Code Style:** Follow existing patterns. Consider adding ESLint/Prettier for consistency.

## Extending the Engine (Creating New Games)

The engine is designed to be configured for different games:

1.  **Configuration (`config/`):**
    * Modify `symbolDefinitions.js` to define new symbols, their payouts, and link to new texture assets.
    * Update `reelStrips.js` with the new symbol sequences for each reel.
    * Adjust `paylines.js` if the payline structure changes.
    * Tweak `gameSettings.js` (e.g., bet levels) and `animationSettings.js` as needed.
2.  **Assets (`public/assets/`):**
    * Add new symbol textures (`images/`).
    * Add new background image (`images/background/`).
    * Add new audio files (`audio/`).
    * Update UI assets/styles (`control/`, `styles/main.css`).
3.  **Custom Features:**
    * For unique symbol behaviours, add custom animations using `registerSymbolAnimation` (see `AnimationDemo.js`).
    * For entirely new features (new bonus types, modifiers), create new modules in `features/` and integrate them into the main game flow (`Game.js`, potentially triggering via server responses).
4.  **Theming:** Adjust background colors (`gameSettings.js`), fonts (`styles/main.css`), button styles (`ButtonFactory.js`, CSS), and replace visual assets.

## Documentation

For more detailed technical plans, improvement ideas, and guides, please refer to the files within the `/docs` directory.
