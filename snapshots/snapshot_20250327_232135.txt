<file_content path="./src//ui/InfoOverlay.js">
// Placeholder import for game state
import { state } from '../core/GameState.js';

// Reference to the DOM element (needs to be initialized, perhaps in UIManager or Game)
let infoOverlayElement = null;

/**
 * Initializes the reference to the info overlay DOM element.
 * Should be called once during setup.
 * @param {HTMLElement} element - The DOM element for the info overlay.
 */
export function initInfoOverlay(element) {
    if (!element) {
        console.error("InfoOverlay: Provided element is invalid.");
        return;
    }
    infoOverlayElement = element;
    console.log("InfoOverlay initialized with element:", infoOverlayElement);
}

/**
 * Updates the content and visibility of the info overlay DOM element
 * based on the current game state (Autoplay, Free Spins).
 */
export function updateInfoOverlay() {
    if (!infoOverlayElement) {
        // console.warn("InfoOverlay: Element not initialized yet.");
        return; // Don't try to update if the element isn't set
    }

    let txt = "";
    if (state.isAutoplaying) {
        txt += `AUTOPLAY: ${state.autoplaySpinsRemaining}<br>`;
    }
    if (state.isInFreeSpins) {
        txt += `FREE SPINS: ${state.freeSpinsRemaining}<br>FS WIN: €${state.totalFreeSpinsWin.toFixed(2)}`;
    }

    if (txt) {
        infoOverlayElement.innerHTML = txt;
        infoOverlayElement.style.display = "block";
    } else {
        infoOverlayElement.innerHTML = ""; // Clear content when not needed
        infoOverlayElement.style.display = "none";
    }
}
</file_content>

<file_content path="./src//ui/ButtonHandlers.js">
/* global PIXI */ // Might be needed for flashing elements later
import { BET_PER_LINE_LEVELS } from '../config/gameSettings.js';
import { NUM_PAYLINES } from '../config/paylines.js'; // Corrected import
// Removed unused import: import { updateAnimationSettings } from '../config/animationSettings.js';

// --- Placeholder Imports (Will be replaced with actual module imports later) ---
// These represent dependencies that need to be resolved once other modules are created.
import { state, updateState } from '../core/GameState.js'; // Assuming GameState exports state object and update function
import { updateDisplays, updateAutoplayButtonState, updateTurboButtonState, setButtonsEnabled } from './UIManager.js'; // Assuming UIManager handles UI updates
import { flashElement } from './Notifications.js'; // Assuming Notifications handles flashing
import { applyTurboSettings as applyTurbo } from '../features/TurboMode.js'; // Assuming TurboMode handles applying settings
import { startSpinLoop } from '../core/Game.js'; // Assuming Game handles starting the spin process

// --- Bet Adjustment ---

function changeBet(direction) {
  // Access state via imported state object
  if (state.isSpinning || state.isTransitioning || state.isInFreeSpins) return;

  let currentLevelIndex = BET_PER_LINE_LEVELS.indexOf(state.currentBetPerLine);

  // Find closest level if current value isn't exact
  if (currentLevelIndex === -1) {
    currentLevelIndex = BET_PER_LINE_LEVELS.findIndex(
      (lvl) => lvl >= state.currentBetPerLine
    );
    if (currentLevelIndex === -1) {
      currentLevelIndex = BET_PER_LINE_LEVELS.length - 1;
    } else if (
      currentLevelIndex > 0 &&
      BET_PER_LINE_LEVELS[currentLevelIndex] > state.currentBetPerLine
    ) {
      currentLevelIndex--;
    }
  }

  let newLevelIndex = currentLevelIndex + direction;
  newLevelIndex = Math.max(
    0,
    Math.min(newLevelIndex, BET_PER_LINE_LEVELS.length - 1)
  );

  // Update state via imported function/object
  updateState({ currentBetPerLine: BET_PER_LINE_LEVELS[newLevelIndex] });
  updateState({ currentTotalBet: state.currentBetPerLine * NUM_PAYLINES }); // Also update total bet

  updateDisplays(); // Update UI
}

export function decreaseBet() {
  changeBet(-1);
}

export function increaseBet() {
  changeBet(1);
}

// --- Autoplay ---

export function toggleAutoplay() {
  if (state.isSpinning || state.isTransitioning || state.isInFreeSpins) return;

  if (state.isAutoplaying) {
    updateState({ isAutoplaying: false, autoplaySpinsRemaining: 0 });
    console.log("Autoplay stopped.");
    setButtonsEnabled(true); // Enable buttons
  } else {
    updateState({ isAutoplaying: true, autoplaySpinsRemaining: state.autoplaySpinsDefault }); // Use default from state
    console.log(`Autoplay started: ${state.autoplaySpinsRemaining} spins.`);
    updateAutoplayButtonState(); // Update button appearance
    startSpin(); // Start the first spin
  }
  // updateInfoOverlay(); // This will be handled by UIManager based on state changes
}


// --- Turbo Mode ---

export function toggleTurbo() {
  if (state.isTransitioning) return; // Prevent toggle during transitions

  const newTurboState = !state.isTurboMode;
  updateState({ isTurboMode: newTurboState }); // Update global state
  console.log(`Turbo: ${state.isTurboMode}`);

  // Apply settings (might involve updating animation config or directly passing values)
  applyTurbo(state.isTurboMode); // Call function from TurboMode feature
  updateTurboButtonState(); // Update button appearance
}


// --- Spin ---

export function startSpin(isFreeSpin = false) {
  if (state.isSpinning || state.isTransitioning) return;

  // Ensure total bet is current
  const currentTotalBet = state.currentBetPerLine * NUM_PAYLINES;
  updateState({ currentTotalBet: currentTotalBet });

  // Check balance only if it's not a free spin
  if (!isFreeSpin && state.balance < currentTotalBet) {
    console.warn("Insufficient funds.");
    // flashElement(balanceText, 0xe74c3c); // Needs reference to balanceText UI element - UIManager should handle this
    if (state.isAutoplaying) {
      // Stop autoplay if funds are insufficient
      updateState({ isAutoplaying: false, autoplaySpinsRemaining: 0 });
      updateAutoplayButtonState();
      // updateInfoOverlay(); // Handled by UIManager
    }
    setButtonsEnabled(true); // Re-enable buttons
    return; // Stop the spin process
  }

  // --- Start the Spin Process ---
  updateState({ isSpinning: true }); // Set master spinning flag
  setButtonsEnabled(false); // Disable controls

  // Reset win display and line graphics (UIManager or specific modules should handle this)
  updateState({ lastTotalWin: 0, winningLinesInfo: [] });
  // winLineGraphics.clear(); // Handled by PaylineGraphics module
  // overlayContainer.removeChildren(); // Handled by Notifications/UIManager

  updateDisplays(); // Update balance/win text immediately

  // Deduct bet if not a free spin
  if (!isFreeSpin) {
    updateState({ balance: state.balance - currentTotalBet });
    // balanceText.text = `€${state.balance.toFixed(2)}`; // Handled by UIManager
  }

  // Reset target stopping index for chained stops
  updateState({ targetStoppingReelIndex: 0 });

  // Initiate the actual reel spinning logic (call function in Game.js or ReelController.js)
  startSpinLoop(state.isTurboMode); // Pass turbo state if needed by the spin loop logic

  // The rest of the spin logic (scheduling stops, handling stop completion)
  // will be managed within the Game/Reel modules and the game loop itself.
}
</file_content>

<file_content path="./src//ui/UIManager.js">
import * as PIXI from 'pixi.js';
import { state } from '../core/GameState.js'; // Assuming state access
import { GAME_WIDTH, bottomUIY } from '../config/gameSettings.js';
import { gsap } from 'gsap'; // Import GSAP for animations

// References to UI elements (Text objects, Buttons)
let uiContainerRef = null;
let balanceText = null;
let winText = null; // Existing static win display
let betText = null;
let winRollupText = null; // New text for animated rollup
let autoplayButton = null;
let turboButton = null;
let spinButton = null;
let betDecreaseButton = null;
let betIncreaseButton = null;
// Add other buttons if they need state management

// Add new variables for free spins UI elements
let freeSpinsIndicator = null;
let freeSpinsCountText = null;
let freeSpinsTotalWinText = null;
let freeSpinsGlow = null;

/**
 * Initializes the UI Manager.
 * Creates text elements and stores references to them and the main UI container.
 * @param {PIXI.Container} uiContainer - The main container for UI elements.
 * @param {object} uiTextStyle - Style object for labels.
 * @param {object} uiValueStyle - Style object for value displays.
 */
export function initUIManager(uiContainer, uiTextStyle, uiValueStyle) {
    if (!uiContainer) {
        console.error("UIManager: Provided uiContainer is invalid.");
        return;
    }
    uiContainerRef = uiContainer;

    // --- Create Text Labels and Value Displays ---

    // Balance (Left Side)
    const balanceLabel = new PIXI.Text({ text: "BALANCE", style: uiTextStyle });
    balanceLabel.anchor.set(0, 0); // Left anchor
    balanceLabel.x = 50; // Position from left
    balanceLabel.y = bottomUIY + 15;
    balanceText = new PIXI.Text({ text: `€${state.balance.toFixed(2)}`, style: uiValueStyle });
    balanceText.anchor.set(0, 0); // Left anchor
    balanceText.x = 50; // Position from left
    balanceText.y = bottomUIY + 40;
    uiContainer.addChild(balanceLabel, balanceText);

    // Win (Center)
    const winLabel = new PIXI.Text({ text: "WIN", style: uiTextStyle });
    winLabel.anchor.set(0.5, 0); // Center anchor
    winLabel.x = GAME_WIDTH / 2;
    winLabel.y = bottomUIY + 15;
    winText = new PIXI.Text({ text: `€${state.lastTotalWin.toFixed(2)}`, style: { ...uiValueStyle, fill: 0xf1c40f, fontSize: 26 } });
    winText.anchor.set(0.5, 0);
    winText.x = GAME_WIDTH / 2;
    winText.y = bottomUIY + 40;
    winText.visible = state.lastTotalWin > 0; // Initially hide if no win
    uiContainer.addChild(winLabel, winText);

    // Win Rollup Text (Initially hidden, positioned similarly to Win)
    // Style can be adjusted for more prominence
    const rollupStyle = { ...uiValueStyle, fill: 0xffd700, fontSize: 48, stroke: { color: 0x000000, width: 4 } };
    winRollupText = new PIXI.Text({ text: `€0.00`, style: rollupStyle });
    winRollupText.anchor.set(0.5, 0);
    winRollupText.x = GAME_WIDTH / 2;
    winRollupText.y = bottomUIY + 30; // Adjust Y position as needed
    winRollupText.visible = false; // Hidden until a win animation starts
    uiContainer.addChild(winRollupText);


    // Bet
    const betLabel = new PIXI.Text({ text: "BET", style: uiTextStyle });
    betLabel.anchor.set(1, 0);
    betLabel.x = GAME_WIDTH - 50;
    betLabel.y = bottomUIY + 15;
    betText = new PIXI.Text({ text: `€${state.currentTotalBet.toFixed(2)}`, style: uiValueStyle });
    betText.anchor.set(1, 0);
    betText.x = GAME_WIDTH - 50;
    betText.y = bottomUIY + 40;
    uiContainer.addChild(betLabel, betText);

    // --- Store Button References (assuming they are named in Game.js) ---
    // Buttons are added by ButtonFactory, find them by name
    spinButton = uiContainer.getChildByName("spinButton");
    autoplayButton = uiContainer.getChildByName("autoplayButton");
    turboButton = uiContainer.getChildByName("turboButton");
    betDecreaseButton = uiContainer.getChildByName("betDecreaseButton");
    betIncreaseButton = uiContainer.getChildByName("betIncreaseButton");

    if (!spinButton || !autoplayButton || !turboButton || !betDecreaseButton || !betIncreaseButton) {
         console.warn("UIManager: Could not find all expected buttons by name in uiContainer.");
    }

    // Set initial button states
    updateAutoplayButtonState();
    updateTurboButtonState();

    // Create free spins indicator (hidden by default)
    createFreeSpinsIndicator(uiContainer);

    console.log("UIManager initialized.");
}

/**
 * Creates the free spins indicator overlay
 * @param {PIXI.Container} container - The UI container
 */
function createFreeSpinsIndicator(container) {
    // Create container for free spins UI elements
    freeSpinsIndicator = new PIXI.Container();
    freeSpinsIndicator.visible = false; // Hide initially
    
    // Position at the top center of the screen
    freeSpinsIndicator.x = GAME_WIDTH / 2;
    freeSpinsIndicator.y = 10;
    
    // Create background panel
    const panel = new PIXI.Graphics();
    panel.beginFill(0x9932CC, 0.85); // Deep purple with transparency
    panel.lineStyle(3, 0xFFD700, 1); // Gold border
    panel.drawRoundedRect(-150, 0, 300, 80, 10); // Centered rectangle
    panel.endFill();
    
    // Add glow filter
    freeSpinsGlow = new PIXI.Graphics();
    freeSpinsGlow.beginFill(0xFFD700, 0.3);
    freeSpinsGlow.drawRoundedRect(-155, -5, 310, 90, 12);
    freeSpinsGlow.endFill();
    freeSpinsGlow.alpha = 0;
    
    // Create title text
    const titleStyle = new PIXI.TextStyle({
        fontFamily: 'Impact, Charcoal, sans-serif',
        fontSize: 24,
        fontWeight: 'bold',
        fill: 0xFFD700, // Single gold color as hex number
        stroke: { color: 0x000000, width: 3 },
        dropShadow: { color: 0x000000, alpha: 0.5, blur: 2, distance: 2 },
        align: 'center'
    });
    
    const title = new PIXI.Text("FREE SPINS", titleStyle);
    title.anchor.set(0.5, 0);
    title.y = 10;
    
    // Create free spins count text
    const countStyle = new PIXI.TextStyle({
        fontFamily: '"Arial Black", Gadget, sans-serif',
        fontSize: 18,
        fill: 0xFFFFFF, // Use hex number instead of string
        fontWeight: 'bold',
        align: 'center'
    });
    
    freeSpinsCountText = new PIXI.Text("Remaining: 10", countStyle);
    freeSpinsCountText.anchor.set(0.5, 0);
    freeSpinsCountText.y = 45;
    
    // Create total win text
    freeSpinsTotalWinText = new PIXI.Text("Total Win: €0.00", countStyle);
    freeSpinsTotalWinText.anchor.set(0.5, 0);
    freeSpinsTotalWinText.y = 45;
    freeSpinsTotalWinText.x = 180; // Position to the right of spins count
    
    // Add all elements to container
    freeSpinsIndicator.addChild(freeSpinsGlow);
    freeSpinsIndicator.addChild(panel);
    freeSpinsIndicator.addChild(title);
    freeSpinsIndicator.addChild(freeSpinsCountText);
    freeSpinsIndicator.addChild(freeSpinsTotalWinText);
    
    // Add to main container
    container.addChild(freeSpinsIndicator);
}

/**
 * Updates the free spins indicator with current state
 */
function updateFreeSpinsIndicator() {
    if (!freeSpinsIndicator || !freeSpinsCountText || !freeSpinsTotalWinText) return;
    
    // Show/hide based on free spins state
    const inFreeSpin = state.isInFreeSpins;
    
    if (inFreeSpin) {
        // Update text content
        freeSpinsCountText.text = `Remaining: ${state.freeSpinsRemaining}`;
        freeSpinsTotalWinText.text = `Win: €${state.totalFreeSpinsWin.toFixed(2)}`;
        
        // Show indicator if not already visible
        if (!freeSpinsIndicator.visible) {
            freeSpinsIndicator.visible = true;
            freeSpinsIndicator.alpha = 0;
            freeSpinsIndicator.y = -50;
            
            // Animate it in
            gsap.to(freeSpinsIndicator, {
                y: 10,
                alpha: 1,
                duration: 0.5,
                ease: "back.out(1.7)"
            });
            
            // Start pulsing glow animation
            startGlowAnimation();
        }
        
        // Flash when spins count changes
        if (freeSpinsIndicator._lastCount && freeSpinsIndicator._lastCount !== state.freeSpinsRemaining) {
            gsap.to(freeSpinsCountText.scale, {
                x: 1.2, y: 1.2,
                duration: 0.2,
                repeat: 1,
                yoyo: true,
                ease: "power1.inOut"
            });
        }
        
        // Store current count for comparison on next update
        freeSpinsIndicator._lastCount = state.freeSpinsRemaining;
        
    } else if (freeSpinsIndicator.visible) {
        // Animate it out
        gsap.to(freeSpinsIndicator, {
            y: -50,
            alpha: 0,
            duration: 0.5,
            ease: "back.in(1.7)",
            onComplete: () => {
                freeSpinsIndicator.visible = false;
                stopGlowAnimation();
            }
        });
    }
}

/**
 * Starts pulsing glow animation
 */
function startGlowAnimation() {
    if (!freeSpinsGlow) return;
    
    // Kill any existing animations
    gsap.killTweensOf(freeSpinsGlow);
    
    // Create pulsing animation
    gsap.to(freeSpinsGlow, {
        alpha: 0.7,
        duration: 1,
        repeat: -1,
        yoyo: true,
        ease: "sine.inOut"
    });
}

/**
 * Stops glow animation
 */
function stopGlowAnimation() {
    if (!freeSpinsGlow) return;
    
    // Kill animation and reset
    gsap.killTweensOf(freeSpinsGlow);
    freeSpinsGlow.alpha = 0;
}

/**
 * Updates the text displays (Balance, Bet, Win) based on the current game state.
 */
export function updateDisplays() {
    if (balanceText) balanceText.text = `€${state.balance.toFixed(2)}`;
    if (betText) betText.text = `€${state.currentTotalBet.toFixed(2)}`;
    if (winText) {
        // Hide static win text if rollup is active (or about to be)
        const rollupVisible = winRollupText && winRollupText.visible;
        winText.text = `€${state.lastTotalWin.toFixed(2)}`;
        // Only show static win if > 0 AND rollup is not visible
        winText.visible = state.lastTotalWin > 0 && !rollupVisible;
    }
    // Update Info Overlay (DOM) - called separately by Game or state change listener
    // updateInfoOverlay();

    // Update the free spins indicator
    updateFreeSpinsIndicator();
}

/**
 * Enables or disables interaction and adjusts alpha for primary game buttons.
 * @param {boolean} enabled - True to enable, false to disable.
 */
export function setButtonsEnabled(enabled) {
    const alpha = enabled ? 1.0 : 0.5;
    const eventMode = enabled ? 'static' : 'none'; // Keep using string literals
    const cursor = enabled ? 'pointer' : 'default';

    const buttonsToToggle = [
        spinButton,
        autoplayButton,
        turboButton,
        betDecreaseButton,
        betIncreaseButton,
    ];

    buttonsToToggle.forEach(button => {
        if (!button) return; // Skip if button reference wasn't found

        // Special handling for bet buttons during free spins
        const isBetButton = button === betDecreaseButton || button === betIncreaseButton;
        const finalEnabled = enabled && !(isBetButton && state.isInFreeSpins);

        button.eventMode = finalEnabled ? 'static' : 'none';
        button.alpha = finalEnabled ? 1.0 : 0.5;
        button.cursor = finalEnabled ? 'pointer' : 'default';
    });

    // Update specific button states after general enable/disable
    updateAutoplayButtonState();
    updateTurboButtonState();
}

/**
 * Updates the visual state of the Autoplay button (icon, color).
 */
export function updateAutoplayButtonState() {
    if (!autoplayButton) return;

    // Set active state if button supports it directly
    if (typeof autoplayButton.setActiveState === 'function') {
        autoplayButton.setActiveState(state.isAutoplaying);
    }

    // Update the icon 
    if (typeof autoplayButton.updateIcon === 'function') {
        // Use play icon when not autoplaying, stop icon when autoplaying
        const newIconType = state.isAutoplaying ? 'stop' : 'autoplay';
        autoplayButton.updateIcon(newIconType);
    }
}

/**
 * Updates the visual state of the Turbo button (color).
 */
export function updateTurboButtonState() {
    if (!turboButton) return;

    // Set active state if button supports it directly
    if (typeof turboButton.setActiveState === 'function') {
        turboButton.setActiveState(state.isTurboMode);
    }
}

/**
 * Returns a reference to the win rollup text element.
 * @returns {PIXI.Text | null}
 */
export function getWinRollupText() {
    return winRollupText;
}
</file_content>

<file_content path="./src//ui/DebugPanel.js">
import * as PIXI from 'pixi.js';
import { state, updateState } from '../core/GameState.js';

let debugContainer = null;
let debugPanel = null;
let forceWinCheckbox = null;

// Use a Map to store checkbox states instead of properties on containers
const checkboxStates = new Map();

/**
 * Initializes the debug panel
 * @param {PIXI.Application} app - The PIXI application instance
 */
export function initDebugPanel(app) {
    // Create a new container for debug elements
    debugContainer = new PIXI.Container();
    debugContainer.visible = false; // Hidden by default
    app.stage.addChild(debugContainer);
    
    // Position in top-right corner
    debugContainer.x = app.screen.width - 250;
    debugContainer.y = 10;
    
    // Create panel background
    debugPanel = new PIXI.Graphics();
    debugPanel.beginFill(0x222222, 0.85);
    debugPanel.drawRect(0, 0, 240, 280);
    debugPanel.endFill();
    
    // Add currentY tracking property to the panel
    // @ts-ignore - Adding custom property for position tracking
    debugPanel.currentY = 40;
    
    debugContainer.addChild(debugPanel);
    
    // Panel title
    const titleStyle = new PIXI.TextStyle({
        fontFamily: 'Arial',
        fontSize: 16,
        fontWeight: 'bold',
        fill: 0xffffff
    });
    
    const title = new PIXI.Text("DEBUG PANEL", titleStyle);
    title.x = 10;
    title.y = 10;
    debugContainer.addChild(title);
    
    // Add toggle button in top-left corner of main screen
    const toggleBtn = new PIXI.Graphics();
    toggleBtn.beginFill(0xff0000, 0.7);
    toggleBtn.drawRect(0, 0, 30, 30);
    toggleBtn.endFill();
    
    const toggleTextStyle = new PIXI.TextStyle({
        fontFamily: 'Arial', 
        fontSize: 16, 
        fontWeight: 'bold', 
        fill: 0xffffff 
    });
    
    const toggleText = new PIXI.Text("D", toggleTextStyle);
    toggleText.x = 10;
    toggleText.y = 7;
    toggleBtn.addChild(toggleText);
    
    toggleBtn.x = 10;
    toggleBtn.y = 10;
    toggleBtn.eventMode = 'static';
    toggleBtn.cursor = 'pointer';
    toggleBtn.on('pointerdown', toggleDebugPanel);
    app.stage.addChild(toggleBtn);
    
    // Add debug options
    createDebugOptions();
    
    // Update currentY based on the height of createDebugOptions section
    // @ts-ignore - Using custom property for position tracking
    debugPanel.currentY = 140; // Set appropriate Y position after debug options
    
    // Add background adjustment section
    addBackgroundAdjustmentSection(debugPanel);
}

/**
 * Creates debug option controls
 */
function createDebugOptions() {
    const labelStyle = new PIXI.TextStyle({
        fontFamily: 'Arial',
        fontSize: 14,
        fill: 0xffffff
    });
    
    let yPos = 50;
    
    // Force Win option with checkbox
    const forceWinLabel = new PIXI.Text("Force Win Every Spin", labelStyle);
    forceWinLabel.x = 10;
    forceWinLabel.y = yPos;
    debugContainer.addChild(forceWinLabel);
    
    // Create checkbox
    forceWinCheckbox = createCheckbox(180, yPos, state.forceWin, 'forceWin');
    debugContainer.addChild(forceWinCheckbox);
    
    yPos += 30;
    
    // Additional debug options can be added here
    // Example: Add balance controls
    const balanceLabel = new PIXI.Text("Add Balance:", labelStyle);
    balanceLabel.x = 10;
    balanceLabel.y = yPos;
    debugContainer.addChild(balanceLabel);
    
    // Add +100 button
    const addBalanceBtn = new PIXI.Graphics();
    addBalanceBtn.beginFill(0x4CAF50);
    addBalanceBtn.drawRect(0, 0, 60, 22);
    addBalanceBtn.endFill();
    
    const btnTextStyle = new PIXI.TextStyle({
        fontFamily: 'Arial', 
        fontSize: 12, 
        fill: 0xffffff 
    });
    
    const btnText = new PIXI.Text("+100", btnTextStyle);
    btnText.x = 15;
    btnText.y = 5;
    addBalanceBtn.addChild(btnText);
    
    addBalanceBtn.x = 120;
    addBalanceBtn.y = yPos;
    addBalanceBtn.eventMode = 'static';
    addBalanceBtn.cursor = 'pointer';
    addBalanceBtn.on('pointerdown', () => {
        updateState({ balance: state.balance + 100 });
        console.log("Debug: Added 100 to balance");
    });
    debugContainer.addChild(addBalanceBtn);
    
    // Update the currentY for the panel
    // @ts-ignore - Using custom property for position tracking
    debugPanel.currentY = yPos + 40; // Set for next section
}

/**
 * Creates a checkbox control
 * @param {number} x - X position
 * @param {number} y - Y position
 * @param {boolean} initialState - Initial checked state
 * @param {string} id - Unique ID for this checkbox
 * @returns {PIXI.Container} - The checkbox container with event handlers
 */
function createCheckbox(x, y, initialState = false, id) {
    const container = new PIXI.Container();
    container.x = x;
    container.y = y;
    
    // Checkbox background
    const box = new PIXI.Graphics();
    box.lineStyle(1, 0xaaaaaa);
    box.beginFill(0x444444);
    box.drawRect(0, 0, 20, 20);
    box.endFill();
    
    // Checkmark (initially visible based on state)
    const checkmark = new PIXI.Graphics();
    checkmark.beginFill(0x00ff00, 0.8);
    checkmark.drawRect(3, 3, 14, 14);
    checkmark.endFill();
    checkmark.visible = initialState;
    
    container.addChild(box);
    container.addChild(checkmark);
    
    // Set up interactivity
    container.eventMode = 'static';
    container.cursor = 'pointer';
    
    // Store initial state in the Map
    checkboxStates.set(id, initialState);
    
    // Add click handler
    container.on('pointerdown', () => {
        const currentState = checkboxStates.get(id);
        const newState = !currentState;
        
        checkboxStates.set(id, newState);
        checkmark.visible = newState;
        
        // Handle specific checkbox actions
        if (id === 'forceWin') {
            console.log(`Debug Panel: Setting forceWin to ${newState}`);
            updateState({ forceWin: newState });
            console.log(`Debug Panel: State after update: isDebugMode=${state.isDebugMode}, forceWin=${state.forceWin}`);
        }
    });
    
    return container;
}

/**
 * Toggles the visibility of the debug panel
 */
function toggleDebugPanel() {
    debugContainer.visible = !debugContainer.visible;
    // Also set master debug flag
    updateState({ isDebugMode: debugContainer.visible });
    console.log(`Debug Panel: Toggled panel visibility to ${debugContainer.visible}`);
    console.log(`Debug Panel: isDebugMode=${state.isDebugMode}, forceWin=${state.forceWin}`);
    
    // Update the state of debug controls to match the game state
    if (debugContainer.visible) {
        if (forceWinCheckbox) {
            checkboxStates.set('forceWin', state.forceWin);
            forceWinCheckbox.getChildAt(1).visible = state.forceWin;
        }
    }
}

/**
 * Updates debug controls to reflect current state
 */
export function updateDebugControls() {
    if (debugContainer && debugContainer.visible) {
        if (forceWinCheckbox) {
            checkboxStates.set('forceWin', state.forceWin);
            forceWinCheckbox.getChildAt(1).visible = state.forceWin;
        }
    }
}

// Add section for background adjustments
function addBackgroundAdjustmentSection(debugPanel) {
    const sectionTitle = new PIXI.Text({
        text: "Background Adjustments",
        style: { 
            fontSize: 14,
            fill: 0xFFFFFF
        }
    });
    sectionTitle.y = debugPanel.currentY;
    debugPanel.addChild(sectionTitle);
    debugPanel.currentY += 20;

    // Add controls for x, y, and scale
    const offsetLabel = new PIXI.Text({
        text: "Offset: X=0, Y=0, Scale=1",
        style: { 
            fontSize: 12,
            fill: 0xCCCCCC
        }
    });
    offsetLabel.y = debugPanel.currentY;
    debugPanel.addChild(offsetLabel);
    debugPanel.currentY += 20;
    
    // Create button with proper fill syntax for Pixi.js v8
    function createButton(x, y, width, height) {
        const btn = new PIXI.Graphics();
        btn.rect(0, 0, width, height);
        btn.fill({ color: 0x444444 });
        btn.stroke({ color: 0x666666, width: 1 });
        btn.x = x;
        btn.y = y;
        return btn;
    }
    
    // X adjustment buttons
    const btnXMinus = createButton(0, debugPanel.currentY, 30, 20);
    const xMinusText = new PIXI.Text({
        text: "X-",
        style: { 
            fontSize: 12,
            fill: 0xFFFFFF
        }
    });
    xMinusText.x = 8;
    xMinusText.y = 4;
    btnXMinus.addChild(xMinusText);
    
    const btnXPlus = createButton(35, debugPanel.currentY, 30, 20);
    const xPlusText = new PIXI.Text({
        text: "X+",
        style: { 
            fontSize: 12,
            fill: 0xFFFFFF
        }
    });
    xPlusText.x = 8;
    xPlusText.y = 4;
    btnXPlus.addChild(xPlusText);
    
    // Y adjustment buttons
    const btnYMinus = createButton(70, debugPanel.currentY, 30, 20);
    const yMinusText = new PIXI.Text({
        text: "Y-",
        style: { 
            fontSize: 12,
            fill: 0xFFFFFF
        }
    });
    yMinusText.x = 8;
    yMinusText.y = 4;
    btnYMinus.addChild(yMinusText);
    
    const btnYPlus = createButton(105, debugPanel.currentY, 30, 20);
    const yPlusText = new PIXI.Text({
        text: "Y+",
        style: { 
            fontSize: 12,
            fill: 0xFFFFFF
        }
    });
    yPlusText.x = 8;
    yPlusText.y = 4;
    btnYPlus.addChild(yPlusText);
    
    // Scale adjustment buttons
    const btnScaleMinus = createButton(140, debugPanel.currentY, 40, 20);
    const scaleMinusText = new PIXI.Text({
        text: "S-",
        style: { 
            fontSize: 12,
            fill: 0xFFFFFF
        }
    });
    scaleMinusText.x = 14;
    scaleMinusText.y = 4;
    btnScaleMinus.addChild(scaleMinusText);
    
    const btnScalePlus = createButton(185, debugPanel.currentY, 40, 20);
    const scalePlusText = new PIXI.Text({
        text: "S+",
        style: { 
            fontSize: 12,
            fill: 0xFFFFFF
        }
    });
    scalePlusText.x = 14;
    scalePlusText.y = 4;
    btnScalePlus.addChild(scalePlusText);
    
    // Add all buttons
    debugPanel.addChild(btnXMinus);
    debugPanel.addChild(btnXPlus);
    debugPanel.addChild(btnYMinus);
    debugPanel.addChild(btnYPlus);
    debugPanel.addChild(btnScaleMinus);
    debugPanel.addChild(btnScalePlus);
    
    // Track adjustment values
    let offsetX = 0;
    let offsetY = 0;
    let scale = 1;
    
    // Set up button interactions
    btnXMinus.eventMode = 'static';
    btnXMinus.cursor = 'pointer';
    btnXMinus.on('pointerdown', () => {
        offsetX -= 5;
        updateBackground();
    });
    
    btnXPlus.eventMode = 'static';
    btnXPlus.cursor = 'pointer';
    btnXPlus.on('pointerdown', () => {
        offsetX += 5;
        updateBackground();
    });
    
    btnYMinus.eventMode = 'static';
    btnYMinus.cursor = 'pointer';
    btnYMinus.on('pointerdown', () => {
        offsetY -= 5;
        updateBackground();
    });
    
    btnYPlus.eventMode = 'static';
    btnYPlus.cursor = 'pointer';
    btnYPlus.on('pointerdown', () => {
        offsetY += 5;
        updateBackground();
    });
    
    btnScaleMinus.eventMode = 'static';
    btnScaleMinus.cursor = 'pointer';
    btnScaleMinus.on('pointerdown', () => {
        scale -= 0.01;
        updateBackground();
    });
    
    btnScalePlus.eventMode = 'static';
    btnScalePlus.cursor = 'pointer';
    btnScalePlus.on('pointerdown', () => {
        scale += 0.01;
        updateBackground();
    });
    
    // Function to update background and label
    function updateBackground() {
        // Update the label
        offsetLabel.text = `Offset: X=${offsetX}, Y=${offsetY}, Scale=${scale.toFixed(2)}`;
        
        // Access game instance using @ts-ignore to bypass type checking
        // @ts-ignore - Accessing dynamically added gameApp property
        if (window.gameApp && typeof window.gameApp.adjustBackground === 'function') {
            // @ts-ignore - Call dynamically available method
            window.gameApp.adjustBackground(offsetX, offsetY, scale);
        }
    }
    
    debugPanel.currentY += 30;
} </file_content>

<file_content path="./src//ui/ButtonFactory.js">
import * as PIXI from 'pixi.js';
import { gsap } from 'gsap'; // Import GSAP

/**
 * Creates a reusable PixiJS button component with improved visuals.
 * @param {string} text - The text label for the button (ignored if iconType is provided).
 * @param {number} x - The x-coordinate position.
 * @param {number} y - The y-coordinate position.
 * @param {function} callback - The function to call when the button is pressed.
 * @param {object} textStyleObject - PIXI.TextStyle properties (used only if no iconType).
 * @param {PIXI.Container} parentContainer - The container to add this button to. Required.
 * @param {number} [width=100] - The width of the button (used for radius if circular).
 * @param {number} [height=40] - The height of the button (used for radius if circular).
 * @param {boolean} [circular=false] - Whether the button should be circular.
 * @param {string} [iconType=undefined] - Optional: Type of icon ('spin', 'turbo', etc.).
 * @returns {Button} The Button instance.
 */
export function createButton(
  text, x, y,
  callback,
  textStyleObject, // Still needed for potential non-icon buttons
  parentContainer,
  width = 100,
  height = 40,
  circular = false,
  iconType = undefined
) {
   // Ensure callback is a function, provide a no-op default if not
   if (typeof callback !== "function") {
     console.warn("createButton: Callback provided is not a function. Using no-op.");
     callback = () => {};
   }

  // Pass iconType to the Button constructor
  const button = new Button(text, x, y, callback, textStyleObject, parentContainer, width, height, circular, iconType);

  // Add the button to the specified parent container
  if (parentContainer) {
      parentContainer.addChild(button);
  } else {
      console.warn("createButton: No parent container provided. Button not added to stage.");
  }

  return button; // Return the created button instance
}

// Load SVG assets for button icons
export async function loadButtonAssets() {
  // Define the SVG assets we need for buttons
  const buttonAssets = [
    { alias: 'btn_spin', src: 'assets/control/spin.svg' },
    { alias: 'btn_turbo', src: 'assets/control/turbo.svg' },
    { alias: 'btn_autoplay', src: 'assets/control/autoplay.svg' },
    { alias: 'btn_plus', src: 'assets/control/plus.svg' },
    { alias: 'btn_minus', src: 'assets/control/minus.svg' }
  ];
  
  try {
    await PIXI.Assets.load(buttonAssets);
    console.log("Button SVG assets loaded successfully");
    return true;
  } catch (error) {
    console.error("Failed to load button SVG assets, falling back to drawn icons:", error);
    return false;
  }
}

/**
 * Represents a custom Button class extending PIXI.Container
 */
class Button extends PIXI.Container {
    /** @type {PIXI.Text | undefined} */
    buttonLabel;
    /** @type {PIXI.Graphics | PIXI.Sprite | undefined} */
    buttonIcon;
    /** @type {PIXI.Graphics | undefined} */
    bgIdle;
    /** @type {PIXI.Graphics | undefined} */
    bgHover;
    /** @type {PIXI.Graphics | undefined} */
    bgDown;
    /** @type {PIXI.Graphics | undefined} */
    bgActive;
    /** @type {gsap.core.Tween | null} */
    currentTween = null;
    /** @type {Function | null} */
    _callback = null;
    _isCircular = false; // Store circular flag
    _width = 0;
    _height = 0;
    _iconType = ""; // Store icon type
    _isActive = false; // Track active state for toggles
    _usingSVG = false; // Whether using SVG icon

    constructor(
        text, x, y,
        callback,
        textStyleObject,
        parentContainer,
        width = 100,
        height = 40,
        circular = false,
        iconType
    ) {
        super();
        this._callback = callback;
        this._isCircular = circular; // Store flag
        this._iconType = iconType || ""; // Store icon type

        // Ensure width and height are numbers
        this._width = Number(width) || 100;
        this._height = Number(height) || 40;
        const effectiveWidth = this._isCircular ? Math.min(this._width, this._height) : this._width;
        const effectiveHeight = this._isCircular ? Math.min(this._width, this._height) : this._height;
        const radius = effectiveWidth / 2;

        this.pivot.set(effectiveWidth / 2, effectiveHeight / 2);
        this.x = x;
        this.y = y;
        /** @type {PIXI.EventMode} */
        this.eventMode = 'static'; // Explicitly set valid EventMode
        this.cursor = "pointer";

        // --- Button Shapes - Enhanced colors ---
        const idleColor = iconType === 'spin' ? 0xEA3323 : 0x555555; // Red for spin, dark gray for others
        const hoverColor = iconType === 'spin' ? 0xFF5544 : 0x777777;
        const downColor = iconType === 'spin' ? 0xCC2211 : 0x3A3A3A;
        const activeColor = 0x224488; // Blue highlight for active state

        // Create backgrounds for different states
        this.bgIdle = this._drawShape(this._width, this._height, this._isCircular, radius, idleColor, 0xaaaaaa);
        this.bgHover = this._drawShape(this._width, this._height, this._isCircular, radius, hoverColor, 0xffffff);
        this.bgDown = this._drawShape(this._width, this._height, this._isCircular, radius, downColor, 0x777777);
        this.bgActive = this._drawShape(this._width, this._height, this._isCircular, radius, activeColor, 0xffffff);

        this.bgHover.visible = false;
        this.bgDown.visible = false;
        this.bgActive.visible = false;

        this.addChild(this.bgIdle);
        this.addChild(this.bgHover);
        this.addChild(this.bgDown);
        this.addChild(this.bgActive);

        // --- Button Content (Icon or Text) ---
        if (iconType) {
            // Try to use SVG icon first, if available
            const svgTexture = PIXI.Assets.get(`btn_${iconType}`);
            if (svgTexture) {
                // Using SVG icon
                this._usingSVG = true;
                const icon = new PIXI.Sprite(svgTexture);
                icon.anchor.set(0.5);
                icon.x = effectiveWidth / 2;
                icon.y = effectiveHeight / 2;
                icon.width = effectiveWidth * 0.6;
                icon.height = effectiveHeight * 0.6;
                icon.tint = 0xFFFFFF; // Set the tint to white to match drawn icons
                this.buttonIcon = icon;
            } else {
                // Fallback to drawn icon
                this._usingSVG = false;
                this.buttonIcon = this._drawIcon(iconType, effectiveWidth, effectiveHeight, radius);
            }
            
            if (this.buttonIcon) {
                this.addChild(this.buttonIcon);
            }
        } else if (text) {
            const style = new PIXI.TextStyle(textStyleObject || {});
            const buttonText = new PIXI.Text({ text: text, style: style });
            buttonText.anchor.set(0.5);
            buttonText.x = effectiveWidth / 2;
            buttonText.y = effectiveHeight / 2;
            this.buttonLabel = buttonText;
            this.addChild(buttonText);
        }

        // Add glow effect for spin button
        if (iconType === 'spin') {
            const glow = new PIXI.Graphics()
                .circle(effectiveWidth / 2, effectiveHeight / 2, radius + 3)
                .fill({ color: 0xFFFFFF, alpha: 0 });
            this.addChildAt(glow, 0); // Add behind everything
            
            gsap.to(glow, {
                alpha: 0.3,
                duration: 1.2,
                repeat: -1,
                yoyo: true,
                ease: "sine.inOut"
            });
        }

        // --- Interaction Logic ---
        this._onPointerDown = this._onPointerDown.bind(this);
        this._onPointerUp = this._onPointerUp.bind(this);
        this._onPointerUpOutside = this._onPointerUpOutside.bind(this);
        this._onPointerOver = this._onPointerOver.bind(this);
        this._onPointerOut = this._onPointerOut.bind(this);

        this.on("pointerdown", this._onPointerDown);
        this.on("pointerup", this._onPointerUp);
        this.on("pointerupoutside", this._onPointerUpOutside);
        this.on("pointerover", this._onPointerOver);
        this.on("pointerout", this._onPointerOut);
    }

    // --- Helper methods for drawing ---

    /**
     * Draws the basic button shape
     * @param {number} width
     * @param {number} height
     * @param {boolean} circular
     * @param {number} radius
     * @param {number} fillColor
     * @param {number} strokeColor
     * @returns {PIXI.Graphics}
     */
    _drawShape(width, height, circular, radius, fillColor, strokeColor) {
        const shape = new PIXI.Graphics();
        if (circular) {
            shape
                .circle(radius, radius, radius)
                .fill({ color: fillColor })
                .stroke({ width: 2, color: strokeColor, alignment: 0.5 });
        } else {
            shape
                .roundRect(0, 0, width, height, 10)
                .fill({ color: fillColor })
                .stroke({ width: 2, color: strokeColor, alignment: 0.5 });
        }
        return shape;
    }

    /**
     * Draws the icon based on type (fallback if SVG not available)
     * @param {string} iconType
     * @param {number} width
     * @param {number} height
     * @param {number} radius - Radius of the button (or half its size)
     * @returns {PIXI.Graphics | undefined} // Return undefined on failure
     */
    _drawIcon(iconType, width, height, radius) {
        const icon = new PIXI.Graphics();
        const iconColor = 0xffffff;
        const centerX = width / 2;
        const centerY = height / 2;
        const size = Math.min(width, height) * 0.5; // Base size for icons
        const strokeWidth = Math.max(2, radius * 0.1);

        switch (iconType) {
            case 'spin':
                const iconRadius = size * 0.8;
                const arrowThickness = Math.max(2, radius * 0.15);
                icon.stroke({ width: arrowThickness, color: iconColor, cap: 'round' });
                icon.arc(centerX, centerY, iconRadius, -Math.PI * 0.1, Math.PI * 0.9);
                this._drawArrowHead(icon, centerX, centerY, iconRadius, Math.PI * 0.9, arrowThickness);
                icon.moveTo(centerX + iconRadius * Math.cos(Math.PI * 0.9), centerY + iconRadius * Math.sin(Math.PI * 0.9));
                icon.stroke({ width: arrowThickness, color: iconColor, cap: 'round' });
                icon.arc(centerX, centerY, iconRadius, Math.PI * 0.9, Math.PI * 1.9);
                this._drawArrowHead(icon, centerX, centerY, iconRadius, Math.PI * 1.9, arrowThickness);
                break;
            case 'plus':
                icon.stroke({ width: strokeWidth, color: iconColor, cap: 'round' });
                icon.moveTo(centerX - size / 2, centerY);
                icon.lineTo(centerX + size / 2, centerY);
                icon.moveTo(centerX, centerY - size / 2);
                icon.lineTo(centerX, centerY + size / 2);
                break;
            case 'minus':
                icon.stroke({ width: strokeWidth, color: iconColor, cap: 'round' });
                icon.moveTo(centerX - size / 2, centerY);
                icon.lineTo(centerX + size / 2, centerY);
                break;
            case 'autoplay':
                icon.moveTo(centerX - size / 3, centerY - size / 2);
                icon.lineTo(centerX + size / 2, centerY);
                icon.lineTo(centerX - size / 3, centerY + size / 2);
                icon.closePath();
                icon.fill({ color: iconColor });
                break;
            case 'turbo':
                icon.moveTo(centerX + size / 3, centerY - size / 2);
                icon.lineTo(centerX - size / 3, centerY + size / 10);
                icon.lineTo(centerX, centerY + size / 10);
                icon.lineTo(centerX - size / 3, centerY + size / 2);
                icon.lineTo(centerX + size / 3, centerY - size / 10);
                icon.lineTo(centerX, centerY - size / 10);
                icon.closePath();
                icon.fill({ color: iconColor });
                break;
            default:
                console.warn("ButtonFactory: Unknown iconType:", iconType);
                return undefined;
        }
        return icon;
    }

    /**
     * Helper to draw arrowhead for spin icon
     * @param {PIXI.Graphics} graphics
     * @param {number} cx
     * @param {number} cy
     * @param {number} radius
     * @param {number} angle
     * @param {number} thickness
     */
    _drawArrowHead(graphics, cx, cy, radius, angle, thickness) {
        const headLength = thickness * 1.5;
        graphics.moveTo(cx + radius * Math.cos(angle), cy + radius * Math.sin(angle));
        graphics.lineTo(cx + radius * Math.cos(angle) - headLength * Math.cos(angle + Math.PI / 6), cy + radius * Math.sin(angle) - headLength * Math.sin(angle + Math.PI / 6));
        graphics.moveTo(cx + radius * Math.cos(angle), cy + radius * Math.sin(angle));
        graphics.lineTo(cx + radius * Math.cos(angle) - headLength * Math.cos(angle - Math.PI / 6), cy + radius * Math.sin(angle) - headLength * Math.sin(angle - Math.PI / 6));
    }

    // --- Interaction Logic with GSAP ---
    /** @param {object} targetProps */
    _animate(targetProps) {
        // Check if tween exists and is active before killing
        if (this.currentTween && this.currentTween.isActive()) {
            this.currentTween.kill();
        }
        this.currentTween = gsap.to(this.scale, { ...targetProps, duration: 0.1, ease: 'power1.out' });
    }

    /** @param {PIXI.FederatedPointerEvent} event */
    _onPointerDown(event) {
        if (this.alpha < 0.6) return; // Basic enabled check
        
        // If it's a toggle button and already active, don't show 'down' state
        if (this._isActive && (this._iconType === 'turbo' || this._iconType === 'autoplay')) {
            return;
        }
        
        if (this.bgDown) this.bgDown.visible = true;
        if (this.bgIdle) this.bgIdle.visible = false;
        if (this.bgHover) this.bgHover.visible = false;
        if (this.bgActive) this.bgActive.visible = false;
        this._animate({ x: 0.95, y: 0.95 });
    }

    /** @param {PIXI.FederatedPointerEvent} event */
    _onPointerUp(event) {
        if (this.alpha < 0.6) return;
        
        // Call the callback first before changing visual state
        if (typeof this._callback === 'function') {
            this._callback();
        }
        
        // Add spin animation specifically for the spin button
        if (this._iconType === 'spin') {
            // Kill any previous rotation animation
            gsap.killTweensOf(this);
            gsap.killTweensOf(this.scale);
            
            // Also kill any tweens on the button icon
            if (this.buttonIcon) {
                gsap.killTweensOf(this.buttonIcon);
            }
            
            // Create a sequence of animations for a more elaborate effect
            const tl = gsap.timeline();
            
            // Initial quick compression
            tl.to(this.scale, {
                x: 0.9, 
                y: 0.9, 
                duration: 0.15,
                ease: "power1.in"
            });
            
            // Spin with slight expansion
            tl.to(this, {
                rotation: Math.PI * 2, // Full 360-degree rotation
                duration: 0.8,
                ease: "power2.inOut"
            }, 0.1);
            
            // Add a flash effect to the icon
            if (this.buttonIcon) {
                // Flash icon bright white (or orange for SVGs)
                const flashColor = this._usingSVG ? 0xFF7700 : 0xFFFFFF;
                const originalTint = this._usingSVG ? 0xFFFFFF : 0xFFFFFF;
                
                tl.to(this.buttonIcon, {
                    tint: flashColor,
                    alpha: 1.5, // Slight overbright
                    duration: 0.2,
                    ease: "sine.in"
                }, 0.2);
                
                // Return to normal
                tl.to(this.buttonIcon, {
                    tint: originalTint,
                    alpha: 1.0,
                    duration: 0.3,
                    ease: "power1.out"
                }, 0.4);
            }
            
            // Expansion with bounce
            tl.to(this.scale, {
                x: 1.1, 
                y: 1.1, 
                duration: 0.3,
                ease: "power2.out"
            }, 0.5);
            
            // Return to normal
            tl.to(this.scale, {
                x: 1.0, 
                y: 1.0, 
                duration: 0.3,
                ease: "elastic.out(1.2, 0.5)"
            }, 0.8);
            
            // Reset rotation when complete
            tl.call(() => {
                this.rotation = 0;
            });
        }
        
        // Reset states - active state will be set by UIManager when state changes
        if (this.bgDown) this.bgDown.visible = false;
        
        // Calculate if pointer is still over the button
        const globalPoint = event.global;
        let isOver = false;
        if (globalPoint) {
            const bounds = this.getBounds();
            isOver = globalPoint.x >= bounds.x && globalPoint.x <= bounds.x + bounds.width &&
                     globalPoint.y >= bounds.y && globalPoint.y <= bounds.y + bounds.height;
        }
        
        // Default to hover or idle state, let UIManager handle active state
        if (this.bgHover) this.bgHover.visible = isOver && !this._isActive;
        if (this.bgIdle) this.bgIdle.visible = !isOver && !this._isActive;
        if (this.bgActive) this.bgActive.visible = this._isActive;
        
        this._animate({ x: isOver ? 1.05 : 1.0, y: isOver ? 1.05 : 1.0 });
    }

    /** @param {PIXI.FederatedPointerEvent} event */
     _onPointerUpOutside(event) {
        if (this.alpha < 0.6) return;
        if (this.bgDown) this.bgDown.visible = false;
        if (this.bgHover) this.bgHover.visible = false;
        
        // If active, show active state, otherwise show idle
        if (this._isActive) {
            if (this.bgActive) this.bgActive.visible = true;
            if (this.bgIdle) this.bgIdle.visible = false;
        } else {
            if (this.bgActive) this.bgActive.visible = false;
            if (this.bgIdle) this.bgIdle.visible = true;
        }
        
        this._animate({ x: 1.0, y: 1.0 });
    }

    /** @param {PIXI.FederatedPointerEvent} event */
    _onPointerOver(event) {
        if (this.alpha < 0.6) return;
        
        // If active, keep showing active state
        if (this._isActive) {
            return;
        }
        
        // Otherwise show hover state
        if (this.bgHover) this.bgHover.visible = true;
        if (this.bgIdle) this.bgIdle.visible = false;
        if (this.bgDown) this.bgDown.visible = false;
        
        this._animate({ x: 1.05, y: 1.05 });
    }

    /** @param {PIXI.FederatedPointerEvent} event */
    _onPointerOut(event) {
        if (this.alpha < 0.6) return;
        
        // If active, continue showing active state
        if (this._isActive) {
            return;
        }
        
        // If currently showing down state, keep that until pointer up/outside
        if (this.bgDown && this.bgDown.visible) {
            return;
        }
        
        // Reset to idle state
        if (this.bgHover) this.bgHover.visible = false;
        if (this.bgIdle) this.bgIdle.visible = true;
        
        this._animate({ x: 1.0, y: 1.0 });
    }

    /**
     * Set active state for buttons like turbo/autoplay
     * @param {boolean} isActive Whether the button should show active state
     */
    setActiveState(isActive) {
        this._isActive = isActive;
        
        // Update visuals
        if (this._isActive) {
            if (this.bgActive) this.bgActive.visible = true;
            if (this.bgIdle) this.bgIdle.visible = false;
            if (this.bgHover) this.bgHover.visible = false;
            if (this.bgDown) this.bgDown.visible = false;
        } else {
            if (this.bgActive) this.bgActive.visible = false;
            if (this.bgIdle) this.bgIdle.visible = true;
            if (this.bgHover) this.bgHover.visible = false;
            if (this.bgDown) this.bgDown.visible = false;
        }
    }

    /**
     * Method to update icon type (needed for autoplay toggle between play/stop)
     * @param {string} newIconType
     */
    updateIcon(newIconType) {
        if (this._iconType === newIconType) return; // No change needed
        
        this._iconType = newIconType;
        
        // Remove existing icon
        if (this.buttonIcon) {
            this.removeChild(this.buttonIcon);
            this.buttonIcon.destroy();
            this.buttonIcon = undefined;
        }

        // Get dimensions for new icon
        const effectiveWidth = this._isCircular ? Math.min(this._width, this._height) : this._width;
        const effectiveHeight = this._isCircular ? Math.min(this._width, this._height) : this._height;
        const radius = effectiveWidth / 2;

        // Try SVG first if we were using it before
        if (this._usingSVG) {
            const svgTexture = PIXI.Assets.get(`btn_${newIconType}`);
            if (svgTexture) {
                const icon = new PIXI.Sprite(svgTexture);
                icon.anchor.set(0.5);
                icon.x = effectiveWidth / 2;
                icon.y = effectiveHeight / 2;
                icon.width = effectiveWidth * 0.6;
                icon.height = effectiveHeight * 0.6;
                icon.tint = 0xFFFFFF; // Set the tint to white
                this.buttonIcon = icon;
                this.addChild(icon);
                return;
            }
        }
        
        // Fallback to drawn icon
        this.buttonIcon = this._drawIcon(newIconType, effectiveWidth, effectiveHeight, radius);
        if (this.buttonIcon) {
            this.addChild(this.buttonIcon);
        }
    }
}
</file_content>

<file_content path="./src//ui/Notifications.js">
import * as PIXI from 'pixi.js';
import { gsap } from 'gsap'; // Import GSAP
import { winAnimDelayMultiplier } from '../config/animationSettings.js';
import { GAME_WIDTH, GAME_HEIGHT } from '../config/gameSettings.js';

// Reference to the overlay container (needs initialization)
let overlayContainer = null;
let currentOverlayTween = null; // To manage GSAP tween
let flashElementInterval = null; // Store interval ID for flashing

/**
 * Initializes the reference to the overlay container.
 * @param {PIXI.Container} container - The Pixi container for overlay messages.
 */
export function initNotifications(container) {
    if (!container) {
        console.error("Notifications: Provided overlay container is invalid.");
        return;
    }
    overlayContainer = container;
    console.log("Notifications initialized with container:", overlayContainer);
}

/**
 * Flashes a PixiJS display object (like Text) with a specific color.
 * @param {PIXI.Container} element - The Pixi element to flash (Container is a common base).
 * @param {number} [flashColor=0xff0000] - The color to flash (hex).
 * @param {number} [baseDuration=150] - Base duration of each flash phase (ms).
 * @param {number} [flashes=2] - Number of full on/off cycles.
 */
export function flashElement(
  element,
  flashColor = 0xff0000,
  baseDuration = 150,
  flashes = 2
) {
  if (flashElementInterval) clearInterval(flashElementInterval); // Clear previous interval
  if (!element?.parent) return; // Don't flash if element isn't on stage

  const originalTint = element.tint ?? 0xffffff;
  let count = 0;
  element.visible = true; // Ensure it's visible

  const duration = baseDuration * winAnimDelayMultiplier; // Adjust duration based on turbo

  function doFlash() {
    if (!element?.parent) { // Stop if element is removed
      clearInterval(flashElementInterval);
      return;
    }
    if (count >= flashes * 2) { // Completed all flashes
      clearInterval(flashElementInterval);
      element.tint = originalTint; // Restore original tint
      // Optionally hide if it's the win text and there's no win? Needs context.
      // if (element === winText && lastTotalWin <= 0) element.visible = false;
      return;
    }
    // Alternate between flash color and original tint
    element.tint = count % 2 === 0 ? flashColor : originalTint;
    count++;
  }

  doFlash(); // Start immediately
  flashElementInterval = setInterval(doFlash, duration);
}

/**
 * Displays a temporary message centered on the screen in the overlay container.
 * @param {string} message - The text message to display (use \n for newlines).
 * @param {number} baseDuration - Base duration to display the message (ms) before fading.
 * @param {function} [callback] - Optional function to call after the message disappears.
 */
export function showOverlayMessage(message, baseDuration, callback) {
  if (!overlayContainer) {
      console.error("Notifications: Overlay container not initialized.");
      return;
  }
  // Kill previous tween if running
  if (currentOverlayTween) {
      currentOverlayTween.kill();
  }
  overlayContainer.removeChildren(); // Clear previous messages

  // Create style for overlay message text
  const style = new PIXI.TextStyle({
    fontFamily: 'Arial, sans-serif',
    fontSize: 28,
    fontWeight: 'bold',
    fill: 0xFFFFFF, // Single color instead of gradient
    stroke: { color: 0x000000, width: 4 },
    align: 'center',
    wordWrap: true,
    wordWrapWidth: GAME_WIDTH * 0.8
  });

  const messageText = new PIXI.Text({
    text: message,
    style: style, // Pass the style object directly
  });
  messageText.anchor.set(0.5);
  messageText.x = GAME_WIDTH / 2;
  messageText.y = GAME_HEIGHT / 2;

  overlayContainer.addChild(messageText);

  // Use GSAP for fade in, hold, and fade out
  const displayDurationSeconds = (baseDuration / 1000) * winAnimDelayMultiplier;
  const fadeDurationSeconds = 0.3 * winAnimDelayMultiplier; // Quick fade

  messageText.alpha = 0; // Start invisible

  currentOverlayTween = gsap.timeline({
      onComplete: () => {
          if (messageText.parent) {
              overlayContainer.removeChild(messageText);
              messageText.destroy();
          }
          if (callback) {
              callback();
          }
          currentOverlayTween = null; // Clear reference
      }
  });

  // Correctly place commas in GSAP .to() calls
  currentOverlayTween.to(messageText, { alpha: 1, duration: fadeDurationSeconds, ease: "power1.inOut" }) // Fade in
                     .to(messageText, { duration: displayDurationSeconds }) // Hold (vars object is optional if only duration is needed)
                     .to(messageText, { alpha: 0, duration: fadeDurationSeconds, ease: "power1.inOut" }); // Fade out
}
</file_content>

<file_content path="./src//Game.js">
import { setupCustomAnimations } from './features/AnimationDemo.js';

// Add the following call after the game is initialized:
// Find the game's initialization function/method and add this after other initialization code
setupCustomAnimations().catch(err => console.error("Failed to setup custom animations:", err)); </file_content>

<file_content path="./src//core/Reel.js">
import * as PIXI from 'pixi.js';
import { gsap } from 'gsap'; // Import GSAP
import { SYMBOL_SIZE, SYMBOLS_PER_REEL_VISIBLE, REEL_WIDTH } from '../config/gameSettings.js';
import {
    spinAcceleration, maxSpinSpeed,
    stopTweenDuration // Import new setting
} from '../config/animationSettings.js'; // Import animation parameters
import { createSymbolGraphic } from './Symbol.js';
// Remove unused helpers: import { lerpAngle, easeOutQuad } from '../utils/helpers.js';

export class Reel {
    constructor(reelIndex, strip, appTicker) {
        this.reelIndex = reelIndex;
        this.strip = strip;
        this.appTicker = appTicker; // Keep ticker reference if needed for 'now'

        this.container = new PIXI.Container();
        this.container.x = reelIndex * REEL_WIDTH;

        this.symbols = []; // Array of PIXI.Container symbol graphics
        this.position = Math.random() * this.strip.length; // Current position on the strip
        this.spinSpeed = 0;
        this.state = 'idle'; // idle, accelerating, spinning, tweeningStop, stopped
        this.stopIndex = 0; // Target index on the strip to stop at
        this.finalStopPosition = 0; // Store the target stop index as final position

        // Properties for scheduled stop tweening
        this.targetStopTime = 0; // Absolute time when the reel should finish stopping
        this.stopTween = null; // Reference to the GSAP tween

        // Enhanced visual effects for spinning
        this.setupSpinEffects();

        // Create initial symbols
        const numSymbolsToCreate = SYMBOLS_PER_REEL_VISIBLE + 2; // +2 for buffer top/bottom
        for (let j = 0; j < numSymbolsToCreate; j++) {
            const symbol = createSymbolGraphic(this.strip[0]); // Start with placeholder
            this.symbols.push(symbol);
            this.container.addChild(symbol);
        }
        this.alignReelSymbols(); // Position initial symbols correctly
    }

    /**
     * Set up enhanced visual effects for spinning animation
     */
    setupSpinEffects() {
        // 1. Motion Blur Filter (improved version of original blur)
        this.motionBlur = new PIXI.BlurFilter();
        this.motionBlur.blurY = 0;
        this.motionBlur.blurX = 0;
        this.motionBlur.quality = 2;
        this.motionBlur.enabled = false;
        
        // 2. Color Matrix Filter for brightness/contrast adjustments during spins
        // this.colorMatrix = new PIXI.ColorMatrixFilter();
        // this.colorMatrix.enabled = false;
        
        // Apply filters to container
        this.container.filters = [this.motionBlur];
        
        // Setup shimmer effect elements (light streaks)
        this.setupShimmerEffect();
    }
    
    /**
     * Create light streak elements for a shimmer effect during spinning
     */
    setupShimmerEffect() {
        // Create shimmer container
        this.shimmerContainer = new PIXI.Container();
        this.container.addChild(this.shimmerContainer);
        
        // Create several diagonal light streaks
        this.lightStreaks = [];
        const numStreaks = 3;
        
        for (let i = 0; i < numStreaks; i++) {
            const streak = new PIXI.Graphics();
            streak.alpha = 0;
            
            // Draw diagonal light streak
            streak.beginFill(0xffffff, 1);
            streak.drawRect(-5, -SYMBOL_SIZE * 3, 10, SYMBOL_SIZE * 6);
            streak.endFill();
            
            // Rotate and position
            streak.pivot.set(0, 0);
            streak.rotation = -Math.PI / 4; // Diagonal angle
            streak.y = SYMBOL_SIZE * (Math.random() * SYMBOLS_PER_REEL_VISIBLE);
            
            this.shimmerContainer.addChild(streak);
            this.lightStreaks.push(streak);
        }
        
        // Hide shimmer container initially
        this.shimmerContainer.visible = false;
    }

    // --- Reel State Control ---

    startSpinning(currentTurbo) {
        this.state = 'accelerating';
        this.spinSpeed = 0; // Start from 0 speed
        
        // Enable and reset all visual effects
        if (this.motionBlur) {
            this.motionBlur.enabled = true;
            this.motionBlur.blurY = 0;
            this.motionBlur.blurX = 0;
        }
        
        if (this.colorMatrix) {
            this.colorMatrix.enabled = true;
            this.colorMatrix.reset(); // Reset to identity matrix
        }
        
        // Show shimmer container and reset streaks
        if (this.shimmerContainer) {
            this.shimmerContainer.visible = true;
            
            if (this.lightStreaks) {
                this.lightStreaks.forEach(streak => {
                    if (streak) {
                        streak.alpha = 0;
                        streak.y = SYMBOL_SIZE * (Math.random() * SYMBOLS_PER_REEL_VISIBLE);
                    }
                });
            }
        }
        
        // Determine random stop index (can be overridden by server/predetermined results later)
        this.stopIndex = Math.floor(Math.random() * this.strip.length);
        this.finalStopPosition = this.stopIndex; // Store the target index
        this.targetStopTime = 0; // Reset target stop time
        if (this.stopTween) { // Kill any previous stop tween
            this.stopTween.kill();
            this.stopTween = null;
        }
        console.log(`Reel ${this.reelIndex}: Starting spin, target stop index: ${this.stopIndex}`);
    }

    // New method to schedule the stop
    scheduleStop(targetStopTime) {
        this.targetStopTime = targetStopTime;
        // The actual transition to tweening will happen in the update loop based on time
    }

    // --- Symbol Alignment ---

    alignReelSymbols() {
        const totalStripSymbols = this.strip.length;
        const numSymbolsInDisplay = this.symbols.length; // e.g., 6 (SYMBOLS_PER_REEL_VISIBLE + 2)
        const currentPosition = this.position; // Use the current reel position

        // Calculate the index of the symbol strip that should be at the *very top* of the visible area
        // Adjusting for the buffer symbol at the top.
        const topVisibleStripIndex = Math.floor(currentPosition) % totalStripSymbols;

        for (let i = 0; i < numSymbolsInDisplay; i++) {
            const symbolSprite = this.symbols[i];
            if (!symbolSprite) continue; // Should not happen if initialized correctly

            // Calculate the target strip index for this sprite slot (i)
            // Index 0 is buffer above, 1 is top visible, ..., numSymbolsInDisplay-1 is buffer below
            // Relative index from the top visible symbol on the strip
            const relativeIndex = i - 1; // -1 for top buffer, 0 for top visible, etc.
            const targetStripIndex = (topVisibleStripIndex + relativeIndex + totalStripSymbols) % totalStripSymbols;

            // Calculate the Y position based on the current reel position (fractional part determines offset)
            const symbolOffset = currentPosition - Math.floor(currentPosition);
            // Position relative to the container's top edge. Anchor is 0.5.
            symbolSprite.y = (relativeIndex - symbolOffset) * SYMBOL_SIZE + (SYMBOL_SIZE / 2);

            const expectedSymbolId = this.strip[targetStripIndex];

            // If the sprite doesn't exist, or its ID doesn't match the expected one, replace it
            if (symbolSprite.symbolId !== expectedSymbolId) {
                const oldSymbolY = symbolSprite.y; // Store Y before removing
                this.container.removeChild(symbolSprite);
                symbolSprite.destroy(); // Destroy the old sprite

                const newSymbol = createSymbolGraphic(expectedSymbolId); // Returns SymbolSprite
                if (newSymbol) {
                    newSymbol.y = oldSymbolY; // Apply stored Y position
                    this.symbols[i] = newSymbol; // Replace in array
                    this.container.addChild(newSymbol); // Add new sprite to container
                } else {
                    // Handle error if symbol creation fails
                    console.error(`Failed to create symbol graphic for ID: ${expectedSymbolId}`);
                }
            }
        }
    }

    /**
     * Updates the visual effects based on spin speed
     * @param {number} normalizedSpeed - Speed value from 0-1
     */
    updateSpinEffects(normalizedSpeed) {
        if (normalizedSpeed <= 0) {
            // Disable all effects when not spinning
            if (this.motionBlur) {
                this.motionBlur.enabled = false;
            }
            if (this.colorMatrix) {
                this.colorMatrix.enabled = false;
            }
            if (this.shimmerContainer) {
                this.shimmerContainer.visible = false;
            }
            return;
        }
        
        // 1. Update motion blur
        if (this.motionBlur) {
            this.motionBlur.enabled = true;
            this.motionBlur.blurY = 12 * normalizedSpeed;
        }
        
        // 2. Update color matrix effects
        if (this.colorMatrix) {
            this.colorMatrix.enabled = true;
            this.colorMatrix.reset();
            
            // Add brightness and contrast adjustments
            this.colorMatrix.brightness(1 + 0.2 * normalizedSpeed, false);
            this.colorMatrix.contrast(1 + 0.1 * normalizedSpeed, false);
        }
        
        // 3. Animate light streaks
        this.updateShimmerEffect(normalizedSpeed);
    }
    
    /**
     * Update shimmer light streaks animation
     * @param {number} normalizedSpeed - Speed value from 0-1
     */
    updateShimmerEffect(normalizedSpeed) {
        // Only show streaks at higher speeds
        if (normalizedSpeed < 0.5 || !this.shimmerContainer || !this.lightStreaks) {
            if (this.shimmerContainer) {
                this.shimmerContainer.visible = false;
            }
            return;
        }
        
        this.shimmerContainer.visible = true;
        
        // Randomly trigger streaks based on speed
        const chanceToShow = normalizedSpeed * 0.02;
        
        this.lightStreaks.forEach(streak => {
            if (!streak) return;
            
            // If streak is not visible, randomly make it appear
            if (streak.alpha <= 0.1 && Math.random() < chanceToShow) {
                // Reset position and animate it
                streak.y = SYMBOL_SIZE * (Math.random() * SYMBOLS_PER_REEL_VISIBLE);
                
                // Create quick fade in/out animation
                gsap.killTweensOf(streak);
                gsap.to(streak, {
                    alpha: 0.7 * normalizedSpeed,
                    duration: 0.1,
                    onComplete: () => {
                        gsap.to(streak, {
                            alpha: 0,
                            duration: 0.3,
                            ease: "power1.out"
                        });
                    }
                });
            }
        });
    }

    // --- Update Logic (Called by Game Loop) ---

    update(delta, now) { // 'now' is the current time from the ticker (performance.now() or similar)
        let needsAlign = false;
        let reelIsActive = true; // Assume active unless stopped/idle

        // Check if it's time to start the stop tween
        if ((this.state === 'accelerating' || this.state === 'spinning') && this.targetStopTime > 0 && now >= this.targetStopTime - stopTweenDuration && !this.stopTween) {
            this.state = 'tweeningStop';
            this.spinSpeed = 0; // Stop applying manual speed changes
            
            // Begin disabling visual effects
            this.updateSpinEffects(0.3); // Start with reduced effects

            // Ensure position is wrapped correctly before starting tween
            const currentPosition = ((this.position % this.strip.length) + this.strip.length) % this.strip.length;
            let targetPosition = this.finalStopPosition;

            // Handle wrap-around for GSAP tweening
            // If the target is just past the wrap point (e.g., target 1, current 15, length 16), add strip.length
            if (Math.abs(targetPosition - currentPosition) > this.strip.length / 2) {
                if (targetPosition < currentPosition) {
                    targetPosition += this.strip.length;
                }
            }

            console.log(`Reel ${this.reelIndex}: Starting GSAP stop tween from ${currentPosition.toFixed(2)} to ${targetPosition.toFixed(2)} at ${now.toFixed(0)}ms`);

            // Create a timeline for smoother animation sequence
            const tl = gsap.timeline();
            
            // First tween: position with simultaneous effects reduction
            tl.to(this, {
                position: targetPosition,
                duration: stopTweenDuration / 1000, // GSAP uses seconds
                ease: 'quad.out', // Use GSAP's easing functions
                onUpdate: () => {
                    needsAlign = true; // Align symbols during tween
                    
                    // Calculate progress of the tween (0 to 1)
                    const progress = 1 - (tl.progress() || 0);
                    
                    // Update visual effects with fading intensity
                    this.updateSpinEffects(progress * 0.3); // Gradually reduce from 0.3 to 0
                },
                onComplete: () => {
                    this.position = this.finalStopPosition; // Ensure exact final position
                    this.state = 'stopped';
                    this.alignReelSymbols();
                    needsAlign = false; // Alignment is done
                    reelIsActive = false; // Mark as stopped
                    
                    // Ensure all effects are disabled
                    this.updateSpinEffects(0);
                    
                    this.stopTween = null; // Clear tween reference
                    console.log(`Reel ${this.reelIndex}: GSAP tween stopped at ${performance.now().toFixed(0)}ms`);
                }
            });
            
            // Store the timeline
            this.stopTween = tl;
        }

        switch (this.state) {
            case 'accelerating':
                this.spinSpeed = Math.min(maxSpinSpeed, this.spinSpeed + spinAcceleration * delta);
                this.position += this.spinSpeed * delta;
                if (this.spinSpeed >= maxSpinSpeed) {
                    this.state = 'spinning';
                    this.spinSpeed = maxSpinSpeed; // Cap speed
                }
                
                // Update visual effects with normalized speed (0-1)
                const normalizedSpeed = this.spinSpeed / maxSpinSpeed;
                this.updateSpinEffects(normalizedSpeed);
                
                needsAlign = true;
                break;

            case 'spinning':
                // Continue spinning at max speed
                this.position += maxSpinSpeed * delta;
                
                // Update visual effects at full intensity
                this.updateSpinEffects(1.0);
                
                needsAlign = true;
                break;

            case 'tweeningStop':
                // GSAP is handling the position update via the tween's onUpdate
                // We just need to ensure symbols are aligned
                if (this.stopTween) { // If tween is active
                    needsAlign = true; // Ensure alignment happens
                } else {
                    // If tween finished unexpectedly or was killed, force state to stopped
                    this.state = 'stopped';
                    this.position = this.finalStopPosition; // Snap to final position
                    needsAlign = true;
                    reelIsActive = false;
                    
                    // Ensure all effects are disabled
                    this.updateSpinEffects(0);
                    
                    console.warn(`Reel ${this.reelIndex}: Tween finished unexpectedly.`);
                }
                break;
                
            case 'stopped':
            case 'idle':
                reelIsActive = false;
                
                // Ensure all effects are disabled
                this.updateSpinEffects(0);
                break;
        } // End Switch

        // Normalize position and align symbols if needed
        if (needsAlign) {
            // Wrap position around strip length
            this.position = ((this.position % this.strip.length) + this.strip.length) % this.strip.length;
            this.alignReelSymbols();
        }

        return reelIsActive; // Return whether the reel is still considered moving/active
    }
}
</file_content>

<file_content path="./src//core/Game.js">
import * as PIXI from 'pixi.js';
import * as SETTINGS from '../config/gameSettings.js';
import { REEL_STRIPS } from '../config/reelStrips.js';
// Import animation settings
import {
    // stopDelayBase, // No longer used directly here
    winAnimDelayMultiplier, // Still used in handleSpinEnd
    REEL_STOP_STAGGER, baseSpinDuration, stopTweenDuration, // Normal settings
    turboBaseSpinDuration, turboReelStopStagger // Turbo settings
} from '../config/animationSettings.js';
import { state, updateState, initGameState } from './GameState.js';
import { Reel } from './Reel.js';
import { createButton, loadButtonAssets } from '../ui/ButtonFactory.js';
import * as handlers from '../ui/ButtonHandlers.js';
import { initInfoOverlay, updateInfoOverlay } from '../ui/InfoOverlay.js';
import { initNotifications } from '../ui/Notifications.js'; // init only
import { initWinEvaluation, evaluateWin } from '../features/WinEvaluation.js';
import { initPaylineGraphics, clearWinLines } from '../features/PaylineGraphics.js'; // Import clearWinLines here
import { initFreeSpins, handleFreeSpinEnd } from '../features/FreeSpins.js';
import { initTurboMode, applyTurboSettings } from '../features/TurboMode.js';
import { initAnimations, updateParticles } from '../features/Animations.js'; // Import updateParticles here
import { initUIManager, updateDisplays, setButtonsEnabled } from '../ui/UIManager.js'; // Assuming UIManager exists
import { handleAutoplayNextSpin } from '../features/Autoplay.js';
import { SYMBOL_DEFINITIONS } from '../config/symbolDefinitions.js'; // Import symbol defs for asset loading
import { initDebugPanel } from '../ui/DebugPanel.js'; // Import debug panel


// --- Module-level variables ---
let app = null;
let reels = [];
let reelContainer, uiContainer, winLineGraphics, overlayContainer, particleContainer;
let infoOverlayElement;

// --- Game Class ---
export class Game {
    constructor(canvasContainerId) {
        this.canvasContainer = document.getElementById(canvasContainerId);
        if (!this.canvasContainer) {
            console.error(`Game Error: Canvas container #${canvasContainerId} not found.`);
            return;
        }
        // Initialize game state with default values
        initGameState();
    }

    async init() {
        try {
            // Make this instance accessible to other modules like the debug panel
            if (typeof window !== 'undefined') {
                // @ts-ignore - Dynamically adding gameApp property
                window.gameApp = this;
            }
            
            // --- PixiJS App Setup ---
            app = new PIXI.Application();
            await app.init({
                width: SETTINGS.GAME_WIDTH,
                height: SETTINGS.GAME_HEIGHT,
                backgroundColor: SETTINGS.normalBgColor,
                resolution: window.devicePixelRatio || 1,
                autoDensity: true,
            });
            // Ensure app and canvas exist before appending
            if (app?.canvas && this.canvasContainer) {
                this.canvasContainer.appendChild(app.canvas);
            } else {
                throw new Error("Pixi Application or canvas could not be initialized.");
            }

            // --- Asset Loading ---
            // Load symbol assets
            const symbolAssets = SYMBOL_DEFINITIONS.map(def => ({
                alias: def.id, // Use symbol ID as alias
                src: `assets/images/${def.id}.png` // Construct path
            }));
            
            // Add background image to assets
            symbolAssets.push({
                alias: 'BG_IMAGE',
                src: 'assets/images/background/bg.png'
            });
            
            console.log("Loading symbol assets:", symbolAssets);
            await PIXI.Assets.load(symbolAssets);
            console.log("Symbol assets loaded.");
            
            // Load button SVG assets
            console.log("Loading button assets...");
            await loadButtonAssets();

            // --- Initialize Core Modules ---
            initFreeSpins(app, reelContainer, reels); // Pass app, reelContainer and reels references

            // --- Create Main Containers ---
            // Create background layer first (lowest z-index)
            const backgroundLayer = new PIXI.Container();
            
            // Create the background sprite
            const bgSprite = new PIXI.Sprite(PIXI.Assets.get('BG_IMAGE'));
            
            // Position the background
            bgSprite.x = SETTINGS.GAME_WIDTH / 2 + SETTINGS.BG_OFFSET_X;
            bgSprite.y = SETTINGS.GAME_HEIGHT / 2 + SETTINGS.BG_OFFSET_Y;
            
            // Scale based on the configured mode
            let scale = 1;
            if (SETTINGS.BG_SCALE_MODE === 'cover') {
                // Cover mode: ensure image covers the entire game area
                const scaleX = SETTINGS.GAME_WIDTH / bgSprite.width;
                const scaleY = SETTINGS.GAME_HEIGHT / bgSprite.height;
                scale = Math.max(scaleX, scaleY) * SETTINGS.BG_SCALE_FACTOR;
            } else if (SETTINGS.BG_SCALE_MODE === 'contain') {
                // Contain mode: ensure entire image fits in the game area
                const scaleX = SETTINGS.GAME_WIDTH / bgSprite.width;
                const scaleY = SETTINGS.GAME_HEIGHT / bgSprite.height;
                scale = Math.min(scaleX, scaleY) * SETTINGS.BG_SCALE_FACTOR;
            } else {
                // Exact mode: use the scale factor directly
                scale = SETTINGS.BG_SCALE_FACTOR;
            }
            
            // Center anchor and apply scale
            bgSprite.anchor.set(0.5);
            bgSprite.scale.set(scale);
            
            // Ensure background doesn't interfere with game play
            bgSprite.eventMode = 'none';
            
            // Add the background to its container
            backgroundLayer.addChild(bgSprite);
            
            // Add background layer to stage
            if (!app?.stage) throw new Error("Pixi stage not available after init.");
            app.stage.addChild(backgroundLayer);
            
            // Store reference to background sprite for adjustments
            this.backgroundSprite = bgSprite;
            
            // Create reel container (middle z-index)
            reelContainer = new PIXI.Container();
            reelContainer.x = SETTINGS.reelAreaX;
            reelContainer.y = SETTINGS.reelAreaY;
            
            // Add slight shadow to reels container for depth
            const reelShadow = new PIXI.Graphics()
                .rect(0, 0, SETTINGS.NUM_REELS * SETTINGS.REEL_WIDTH, SETTINGS.REEL_VISIBLE_HEIGHT)
                .fill({ color: 0x000000, alpha: 0.2 });
            reelContainer.addChild(reelShadow);
            
            app.stage.addChild(reelContainer);

            uiContainer = new PIXI.Container();
            app.stage.addChild(uiContainer); // Add UI container first? Or last? Check layering.

            winLineGraphics = new PIXI.Graphics();
            // Position set in initPaylineGraphics
            app.stage.addChild(winLineGraphics);

            overlayContainer = new PIXI.Container(); // For win messages, etc.
            app.stage.addChild(overlayContainer);

            particleContainer = new PIXI.Container(); // For particle effects
            app.stage.addChild(particleContainer);

            // --- Initialize Feature/UI Modules with Containers ---
            initPaylineGraphics(winLineGraphics);
            initNotifications(overlayContainer); // Pass overlay container
            initAnimations(overlayContainer, particleContainer); // Pass relevant containers
            initTurboMode(reels); // Pass reels array reference

            // --- Create Reels ---
            for (let i = 0; i < SETTINGS.NUM_REELS; i++) {
                const reel = new Reel(i, REEL_STRIPS[i], app.ticker);
                reels.push(reel);
                reelContainer.addChild(reel.container);
            }
            initWinEvaluation(reels); // Pass reels array reference

            // --- Reel Mask ---
            const reelMask = new PIXI.Graphics()
                .rect(SETTINGS.reelAreaX, SETTINGS.reelAreaY, SETTINGS.NUM_REELS * SETTINGS.REEL_WIDTH, SETTINGS.REEL_VISIBLE_HEIGHT)
                .fill(0xffffff);
            reelContainer.mask = reelMask;
            if (app?.stage) { // Check again before adding mask
               app.stage.addChild(reelMask); // Mask needs to be added to stage
            }

            // --- Setup UI ---
            this.setupUI(); // Call UI setup method

            // --- Initialize Info Overlay (DOM) ---
            infoOverlayElement = document.getElementById('infoOverlay'); // Get DOM element
            if (infoOverlayElement) {
                initInfoOverlay(infoOverlayElement); // Initialize the module
                updateInfoOverlay(); // Initial update
            } else {
                console.warn("Game Setup: infoOverlay element not found in DOM.");
            }

            // --- Initialize Debug Panel ---
            initDebugPanel(app);

            // --- Final Setup ---
            updateDisplays(); // Initial UI text update
            setButtonsEnabled(true); // Enable buttons initially
            applyTurboSettings(state.isTurboMode); // Apply initial turbo settings

            // --- Start Game Loop ---
            // Ensure app and ticker exist before adding update loop
            if (app?.ticker) {
                app.ticker.add(this.update.bind(this)); // Add bound update method to ticker
            } else {
                 throw new Error("Pixi ticker not available after init.");
            }

            console.log("Game Initialized Successfully");

        } catch (err) {
            console.error("PixiJS or Game Init Failed:", err);
            if (this.canvasContainer) {
                this.canvasContainer.innerHTML = `Error initializing graphics: ${err.message}. Check console.`;
            }
        }
    }

    setupUI() {
        // --- Title ---
        const titleStyle = {
             fontFamily: "Impact, Charcoal, sans-serif",
             fontSize: 40,
             // Use a single color for fill as PixiJS expects
             fill: 0xffd700, // Gold color
             stroke: { color: "#8B0000", width: 3 },
             dropShadow: { color: "#000000", distance: 4, blur: 4, angle: Math.PI / 4, alpha: 0.7 }
            };
        const titleText = new PIXI.Text({ text: "MAD SCIENTIST", style: titleStyle });
        titleText.anchor.set(0.5, 0);
        titleText.x = SETTINGS.GAME_WIDTH / 2;
        titleText.y = 15;
        // Ensure app and stage exist before adding title
        if (app && app.stage) { // More explicit check
            app.stage.addChild(titleText); // Add title directly to stage
        }

        // --- UI Panel ---
        const panelHeight = 100;
        const panel = new PIXI.Graphics()
            .rect(0, SETTINGS.GAME_HEIGHT - panelHeight, SETTINGS.GAME_WIDTH, panelHeight)
            .fill({ color: 0x1a1a1a, alpha: 0.85 });
        if (uiContainer) { // Add check for uiContainer
            uiContainer.addChild(panel);
        }

        // --- Text Styles ---
        const uiTextStyle = { fontFamily: "Arial, sans-serif", fontSize: 18, fill: 0xdddddd };
        const uiValueStyle = { fontFamily: '"Arial Black", Gadget, sans-serif', fontSize: 22, fill: 0xffffff, stroke: { color: 0x000000, width: 2 } };
        const buttonTextStyle = { fontFamily: '"Arial Black", Gadget, sans-serif', fontSize: 20, fill: 0xffffff };

        // --- Create UI Elements (using UIManager) ---
        // UIManager should handle creation and storing references
        initUIManager(uiContainer, uiTextStyle, uiValueStyle);

        // --- Create Buttons (using ButtonFactory and handlers) ---
        const bottomUIY = SETTINGS.bottomUIY;
        const btnW = 45, btnH = 45; // Slightly larger buttons
        const spinBtnSize = 85; // Larger spin button

        // Improved button positioning
        // Bet Buttons (Using iconType)
        createButton("", SETTINGS.GAME_WIDTH - 180, bottomUIY + 52, handlers.decreaseBet, {}, uiContainer, btnW, btnH, false, 'minus').name = "betDecreaseButton";
        createButton("", SETTINGS.GAME_WIDTH - 115, bottomUIY + 52, handlers.increaseBet, {}, uiContainer, btnW, btnH, false, 'plus').name = "betIncreaseButton";

        // Spin Button (Circular with Icon) - Positioned more prominently
        createButton("", SETTINGS.GAME_WIDTH - 80, SETTINGS.GAME_HEIGHT / 2 + 80, handlers.startSpin, {}, uiContainer, spinBtnSize, spinBtnSize, true, 'spin').name = "spinButton";

        // Turbo Button (Using iconType) - Positioned with better spacing
        createButton("", 100, bottomUIY + 52, handlers.toggleTurbo, {}, uiContainer, btnW, btnH, false, 'turbo').name = "turboButton";

        // Autoplay Button (Using iconType)
        createButton("", 180, bottomUIY + 52, handlers.toggleAutoplay, {}, uiContainer, btnW, btnH, false, 'autoplay').name = "autoplayButton";
    }

    update(ticker) {
        const delta = ticker.deltaTime;
        const now = ticker.lastTime;
        let anyReelMoving = false;

        try {
            // Update all reels
            reels.forEach(reel => {
                const isActive = reel.update(delta, now);
                if (isActive) {
                    anyReelMoving = true;
                }
            });

            // Update particle animations
            updateParticles(delta);

            // Update button states in improved UI if state changes
           // updateButtonStates();

            // Check if the spin has just ended
            if (state.isSpinning && !anyReelMoving) {
                this.handleSpinEnd();
            }
            
        } catch (err) {
            console.error("Error in game loop:", err);
            // Ensure app and ticker exist before stopping
            if (app?.ticker) {
                app.ticker.stop(); // Stop the loop on critical error
            }
            alert("Game loop critical error. Check console.");
        }
    }

    handleSpinEnd() {
        updateState({ isSpinning: false, isTransitioning: true }); // Mark as transitioning
        console.log("All reels stopped moving (final check).");

        // Short delay before evaluating wins to allow final animations/settling
        setTimeout(() => {
            console.log("Evaluating wins...");
            evaluateWin(); // Evaluate wins (updates state.lastTotalWin, etc.)

            updateState({ isTransitioning: false }); // End transition after evaluation

            // Check game state to decide next action
            if (state.isInFreeSpins) {
                // Call the handleFreeSpinEnd function directly
                handleFreeSpinEnd();
            } else if (state.isAutoplaying) {
                handleAutoplayNextSpin(); // Check if next autoplay spin should start
            } else {
                setButtonsEnabled(true); // Re-enable buttons for manual play
            }
        }, 50 * winAnimDelayMultiplier); // Use animation multiplier for delay
    }

    /**
     * Start the spinning process for all reels
     */
    startSpinLoop() {
        // Schedule each reel to stop after a delay
        let winPattern = null;
        
        // If force win is enabled, generate a winning pattern before starting the spins
        if (state.isDebugMode && state.forceWin) {
          console.log("Debug mode active: Forcing a win pattern");
          winPattern = this.generateRandomWinPattern();
          console.log("Generated win pattern:", winPattern);
        }
        
        for (let i = 0; i < reels.length; i++) {
          const reel = reels[i];
          
          // Start spinning the reel
          reel.startSpinning();
          
          // Schedule when to stop the reel
          // Use the animation settings constants
          const stopDelay = baseSpinDuration + (i * REEL_STOP_STAGGER);
          
          setTimeout(() => {
            // If in debug mode and force win is enabled, use the predetermined winning pattern
            if (state.isDebugMode && state.forceWin && winPattern) {
              // Find stop position that will show the target symbol in the correct position
              const stopIndex = this.findStopIndexForSymbol(reel, winPattern.symbol, winPattern.positions[i]);
              reel.scheduleStop(stopIndex);
            } else {
              // Normal random stop logic
              const randomStopIndex = Math.floor(Math.random() * reel.totalSymbols);
              reel.scheduleStop(randomStopIndex);
            }
          }, stopDelay);
        }
    }
    
    /**
     * Generate a random winning pattern
     * @returns {{symbol: string, positions: number[]}} A winning pattern with symbol and positions
     */
    generateRandomWinPattern() {
        // Use only high-value symbols for testing
        const highValueSymbols = ["FACE1", "FACE2", "FACE3", "KNIFE", "CUP", "PATCH"];
        
        // Choose a random high-value symbol
        const winSymbol = highValueSymbols[Math.floor(Math.random() * highValueSymbols.length)];
        
        // For simplicity, always use the middle row (index 1) for our winning line
        const rowIndex = 1;
        
        // Determine win length - favor longer wins for testing
        const winLength = Math.floor(Math.random() * 3) + 3; // 3, 4, or 5
        
        // Generate positions array (showing which row the symbol should appear on each reel)
        const positions = [];
        for (let i = 0; i < SETTINGS.NUM_REELS; i++) {
          // For reels within our win length, use the selected row
          if (i < winLength) {
            positions.push(rowIndex);
          } else {
            // For reels beyond our win length, use random positions
            positions.push(Math.floor(Math.random() * SETTINGS.SYMBOLS_PER_REEL_VISIBLE));
          }
        }
        
        return {
          symbol: winSymbol,
          positions: positions
        };
    }
    
    /**
     * Find the stop index that will show the target symbol in the target position
     * @param {Object} reel - The reel object
     * @param {string} targetSymbol - The symbol we want to show
     * @param {number} targetPosition - The position where we want the symbol (0=top, 1=middle, 2=bottom)
     * @returns {number} The stop index that will show the target symbol in position
     */
    findStopIndexForSymbol(reel, targetSymbol, targetPosition) {
        // Get the current sequence of symbols on the reel
        const symbols = reel.symbolsSequence;
        
        // Try to find the target symbol
        for (let i = 0; i < symbols.length; i++) {
          if (symbols[i].name === targetSymbol) {
            // Calculate the stop index that would place this symbol at the target position
            // The stop index must be adjusted for the target position
            let stopIndex = (i - targetPosition) % symbols.length;
            if (stopIndex < 0) stopIndex += symbols.length;
            
            return stopIndex;
          }
        }
        
        // Fallback: if the symbol isn't found, use a random stop position
        console.log(`Could not find symbol ${targetSymbol} on reel - using random position`);
        return Math.floor(Math.random() * reel.totalSymbols);
    }

    /**
     * Allows dynamic adjustment of the background position and scale
     * @param {number} offsetX - X-axis offset adjustment
     * @param {number} offsetY - Y-axis offset adjustment
     * @param {number} scale - Scale adjustment factor
     */
    adjustBackground(offsetX, offsetY, scale) {
        if (!this.backgroundSprite) return;
        
        // Update position
        this.backgroundSprite.x = SETTINGS.GAME_WIDTH / 2 + offsetX;
        this.backgroundSprite.y = SETTINGS.GAME_HEIGHT / 2 + offsetY;
        
        // Update scale with current factor
        const baseScale = SETTINGS.BG_SCALE_MODE === 'cover' 
            ? Math.max(SETTINGS.GAME_WIDTH / this.backgroundSprite.texture.width, 
                      SETTINGS.GAME_HEIGHT / this.backgroundSprite.texture.height)
            : SETTINGS.BG_SCALE_MODE === 'contain'
                ? Math.min(SETTINGS.GAME_WIDTH / this.backgroundSprite.texture.width,
                          SETTINGS.GAME_HEIGHT / this.backgroundSprite.texture.height)
                : 1;
                
        this.backgroundSprite.scale.set(baseScale * scale);
        
        console.log(`Background adjusted: offset(${offsetX}, ${offsetY}), scale: ${scale}`);
    }
}

// --- Global Functions used by other modules ---

/**
 * Starts the spinning process for all reels.
 * Called by ButtonHandlers.startSpin.
 */
export function startSpinLoop(isTurbo) {
    // Clear previous win lines before starting spin
    clearWinLines();

    // Get current time to calculate absolute stop times
    // Note: app.ticker.lastTime might be more accurate if available globally or passed in
    const startTime = performance.now();

    // If debug mode with force win is enabled, generate a winning pattern for all reels
    let winPattern = null;
    if (state.isDebugMode && state.forceWin) {
        winPattern = generateRandomWinPattern();
        console.log(`Debug - Forcing win with ${winPattern.symbol} on line ${winPattern.line}`);
    }

    // Start all reels spinning and schedule their stops
    reels.forEach((reel, i) => {
        reel.startSpinning(isTurbo); // Start spinning visually
        
        // Apply the winning pattern if debug mode is enabled
        if (winPattern) {
            reel.stopIndex = winPattern.stopIndices[i];
            reel.finalStopPosition = winPattern.stopIndices[i];
        }

        // Calculate the absolute time this reel should come to a complete stop
        // Select duration and stagger based on turbo state
        const currentBaseDuration = state.isTurboMode ? turboBaseSpinDuration : baseSpinDuration;
        const currentStagger = state.isTurboMode ? turboReelStopStagger : REEL_STOP_STAGGER;

        const targetStopTime = startTime + currentBaseDuration + i * currentStagger;

        // Tell the reel when to stop and which index to target
        // (stopIndex is determined internally by the reel in startSpinning for now)
        reel.scheduleStop(targetStopTime);
        console.log(`Game: Reel ${i} scheduled to stop at ${targetStopTime.toFixed(0)}ms`);
    });

    // No need for targetStoppingReelIndex or setTimeout for initiation
    updateState({ targetStoppingReelIndex: -1 });
}

/**
 * Generates a random winning pattern for the reels
 * @returns {Object} Object containing symbol, line number, and stop indices
 */
function generateRandomWinPattern() {
    // Use high-value symbols for better wins
    const winningSymbols = ["FACE1", "FACE2", "FACE3", "KNIFE", "CUP", "PATCH"];
    
    // Choose a random symbol
    const symbolIndex = Math.floor(Math.random() * winningSymbols.length);
    const symbol = winningSymbols[symbolIndex];
    
    // For simplicity and reliability, use the middle row (line index 1)
    // This is the most reliable way to create wins
    const paylineIndex = 1;
    
    // Choose a random win length (3, 4, or 5)
    // Bias toward 5 to get bigger wins for testing
    const winLength = Math.random() < 0.5 ? 5 : (Math.random() < 0.7 ? 4 : 3);
    
    console.log(`Debug - Creating win pattern with ${symbol} for ${winLength} reels on middle row`);
    
    // For each reel, find positions where our symbol can appear
    const stopIndices = [];
    
    for (let i = 0; i < REEL_STRIPS.length; i++) {
        const strip = REEL_STRIPS[i];
        
        // For reels that should show the winning symbol
        if (i < winLength) {
            // Find all positions of the target symbol
            const symbolPositions = [];
            for (let j = 0; j < strip.length; j++) {
                if (strip[j] === symbol) {
                    symbolPositions.push(j);
                }
            }
            
            // If we couldn't find the symbol on this reel, look for any high value symbol
            if (symbolPositions.length === 0) {
                // Use a fallback symbol from our list
                for (const fallbackSymbol of winningSymbols) {
                    if (fallbackSymbol === symbol) continue; // Skip the one we already tried
                    
                    // Check if this fallback symbol exists on the reel
                    for (let j = 0; j < strip.length; j++) {
                        if (strip[j] === fallbackSymbol) {
                            symbolPositions.push(j);
                        }
                    }
                    
                    if (symbolPositions.length > 0) {
                        console.log(`Debug - Using fallback symbol ${fallbackSymbol} on reel ${i}`);
                        break; // Found a fallback symbol
                    }
                }
                
                // Last resort fallback
                if (symbolPositions.length === 0) {
                    const randomPos = Math.floor(Math.random() * strip.length);
                    symbolPositions.push(randomPos);
                    console.log(`Debug - Using random position on reel ${i} as last resort`);
                }
            }
            
            // Choose random position from our found positions
            const randomPosition = symbolPositions[Math.floor(Math.random() * symbolPositions.length)];
            
            // For middle row, offset is 1
            const offset = 1;
            
            // Calculate the stop index that places the symbol in the middle row
            // We need to "back up" the strip by the offset to get the symbol at the right row
            const stopIndex = (randomPosition - offset + strip.length) % strip.length;
            stopIndices.push(stopIndex);
        } 
        else {
            // For reels beyond our win length, place random symbols
            const stopIndex = Math.floor(Math.random() * strip.length);
            stopIndices.push(stopIndex);
        }
    }
    
    return {
        symbol: symbol,
        line: paylineIndex,
        stopIndices: stopIndices
    };
}
</file_content>

<file_content path="./src//core/Symbol.js">
import * as PIXI from 'pixi.js';
// Removed SYMBOL_DEFINITIONS import for now, will be used later for texture mapping
import { SYMBOL_SIZE, REEL_WIDTH } from '../config/gameSettings.js';

/**
 * Creates a PixiJS Sprite representation for a given symbol ID.
 * @param {string} symbolId - The ID of the symbol (e.g., "FACE1", "SCAT").
 * @returns {SymbolSprite} An instance of the SymbolSprite class.
 */
export function createSymbolGraphic(symbolId) { // Keep function name for compatibility
  return new SymbolSprite(symbolId);
}

/**
 * Represents a single symbol sprite on the reel.
 * Extends PIXI.Sprite for better performance.
 */
export class SymbolSprite extends PIXI.Sprite { // Rename class to SymbolSprite
  symbolId; // The ID of the symbol ('FACE1', 'SCAT', etc.)
  isAnimating = false; // Flag for win animations
  customFilters = []; // Track custom filters separately from base filters

  constructor(symbolId) {
    // TODO: Replace placeholder with actual texture loading based on symbolId
    // Use the preloaded texture from PIXI.Assets by its alias (which is the symbolId)
    const texture = PIXI.Assets.get(symbolId);
    if (!texture) {
        console.error(`Texture not found for symbol ID: ${symbolId}. Ensure it was preloaded.`);
        // Use a fallback texture or handle error appropriately
        super(PIXI.Texture.WHITE); // Fallback to a white square
    } else {
        super(texture); // Call PIXI.Sprite constructor with the loaded texture
    }
    this.symbolId = symbolId;

    // Set anchor to center for positioning and scaling
    this.anchor.set(0.5);

    // Set size (optional, adjust as needed based on texture size)
    this.width = SYMBOL_SIZE * 0.9;
    this.height = SYMBOL_SIZE * 0.9;

    // Position in the center of the reel width (x is relative to parent container)
    this.x = REEL_WIDTH / 2;

    // Y position will be set by alignReelSymbols in Reel.js
  }
  
  /**
   * Adds a visual effect filter to the symbol
   * @param {PIXI.Filter} filter - The PIXI filter to add
   * @param {string} [name] - Optional name to reference this filter later
   * @returns {PIXI.Filter} The added filter
   */
  addFilter(filter, name) {
    // Initialize filters array if not exists
    if (!this.filters) {
      this.filters = [];
    }
    
    // Add name property to filter for reference
    if (name) {
      filter.name = name;
    }
    
    // Add to both arrays
    this.filters.push(filter);
    this.customFilters.push(filter);
    
    return filter;
  }
  
  /**
   * Removes a filter by reference or name
   * @param {PIXI.Filter|string} filterOrName - Filter object or name to remove
   * @returns {boolean} True if filter was found and removed
   */
  removeFilter(filterOrName) {
    if (!this.filters || !this.customFilters.length) return false;
    
    let filterIndex = -1;
    
    if (typeof filterOrName === 'string') {
      // Find by name
      filterIndex = this.filters.findIndex(f => f.name === filterOrName);
    } else {
      // Find by reference
      filterIndex = this.filters.indexOf(filterOrName);
    }
    
    if (filterIndex >= 0) {
      const removedFilter = this.filters.splice(filterIndex, 1)[0];
      
      // Also remove from our tracking array
      const customIndex = this.customFilters.indexOf(removedFilter);
      if (customIndex >= 0) {
        this.customFilters.splice(customIndex, 1);
      }
      
      // If no more filters, set to null
      if (this.filters.length === 0) {
        this.filters = null;
      }
      
      return true;
    }
    
    return false;
  }
  
  /**
   * Removes all custom filters that were added
   */
  clearCustomFilters() {
    if (!this.filters) return;
    
    // Remove all custom filters from main filters array
    this.customFilters.forEach(filter => {
      const index = this.filters.indexOf(filter);
      if (index >= 0) {
        this.filters.splice(index, 1);
      }
    });
    
    // Clear the custom filters array
    this.customFilters = [];
    
    // If no more filters, set to null
    if (this.filters.length === 0) {
      this.filters = null;
    }
  }
  
  /**
   * Gets a filter by name
   * @param {string} name - The name of the filter to find
   * @returns {PIXI.Filter|null} The filter or null if not found
   */
  getFilter(name) {
    if (!this.filters) return null;
    return this.filters.find(f => f.name === name) || null;
  }
}
</file_content>

<file_content path="./src//core/GameState.js">
import { AUTOPLAY_SPINS_DEFAULT, BET_PER_LINE_LEVELS, NUM_REELS } from '../config/gameSettings.js'; // Import NUM_REELS
import { NUM_PAYLINES } from '../config/paylines.js'; // Corrected import

// --- Central Game State ---
// Using 'let' for properties that change, 'const' for initial settings if not modified elsewhere.
export let state = {
    // Core gameplay
    balance: 10000,
    currentBetPerLine: BET_PER_LINE_LEVELS[3] || 0.1, // Default to a mid-level bet
    currentTotalBet: (BET_PER_LINE_LEVELS[3] || 0.1) * NUM_PAYLINES,
    numReels: NUM_REELS, // Add number of reels to state
    lastTotalWin: 0,
    /** @type {Array<{lineIndex: number, symbolId: string, count: number, winAmount: number, symbols: Array<import('./Symbol.js').Symbol>}>} */
    winningLinesInfo: [], // Array of { lineIndex, symbolId, count, winAmount, symbols }

    // Spin state
    isSpinning: false,      // Master flag: Are reels currently spinning/stopping?
    isTransitioning: false, // Is the game in a non-interactive transition (e.g., FS entry/exit message)?
    targetStoppingReelIndex: -1, // Which reel index is expected to stop next (for chained stops)

    // Features state
    isAutoplaying: false,
    autoplaySpinsRemaining: 0,
    autoplaySpinsDefault: AUTOPLAY_SPINS_DEFAULT, // Store the default value
    isTurboMode: false,
    isInFreeSpins: false,
    freeSpinsRemaining: 0,
    totalFreeSpinsWin: 0,

    // Debug features
    isDebugMode: false,     // Master toggle for debug features
    forceWin: false,        // When true, every spin will result in a win

    // References (can be set during initialization if needed, though maybe better managed in Game.js)
    // reels: [], // Maybe keep reel references in Game.js instead?
    // uiElements: {}, // Maybe keep UI references in UIManager.js?
};

/**
 * Initializes the game state to default values.
 * Can be called at the start or to reset the game.
 */
export function initGameState() {
    state = {
        ...state, // Keep potential references if any were added dynamically
        balance: 10000,
        currentBetPerLine: BET_PER_LINE_LEVELS[3] || 0.1,
        currentTotalBet: (BET_PER_LINE_LEVELS[3] || 0.1) * NUM_PAYLINES,
        numReels: NUM_REELS, // Add number of reels to state reset
        lastTotalWin: 0,
        winningLinesInfo: [], // Reset to empty array
        isSpinning: false,
        isTransitioning: false,
        targetStoppingReelIndex: -1,
        isAutoplaying: false,
        autoplaySpinsRemaining: 0,
        isTurboMode: false, // Reset turbo on init? Or keep user preference? Let's reset for now.
        isInFreeSpins: false,
        freeSpinsRemaining: 0,
        totalFreeSpinsWin: 0,
        
        // Debug features - reset to false on game init
        isDebugMode: false,
        forceWin: false,
    };
    console.log("GameState Initialized:", state);
}

/**
 * Updates the central game state object with new values.
 * Merges the provided updates with the existing state.
 * @param {Partial<state>} updates - An object containing state properties to update.
 */
export function updateState(updates) {
    // Basic merge, could add validation or logging later
    state = { ...state, ...updates };
    // console.log("GameState Updated:", updates, "New State:", state); // Optional: Log updates
}

// Optional: Add getter functions if direct state access is discouraged later
// export function getBalance() { return state.balance; }
// export function isSpinning() { return state.isSpinning; }
// ... etc.
</file_content>

<file_content path="./src//config/gameSettings.js">
export const GAME_WIDTH = 1000;
export const GAME_HEIGHT = 700;
export const NUM_REELS = 5;
export const SYMBOLS_PER_REEL_VISIBLE = 4;
export const REEL_WIDTH = 150;
export const SYMBOL_SIZE = 130;
export const SCATTER_SYMBOL_ID = "SCAT";
export const MIN_SCATTERS_FOR_FREE_SPINS = 3;
export const FREE_SPINS_AWARDED = 10;
export const AUTOPLAY_SPINS_DEFAULT = 10;
export const BET_PER_LINE_LEVELS = [0.01, 0.02, 0.05, 0.1, 0.2, 0.5, 1.0, 2.0];
export const ENABLE_FREE_SPINS = true; // Config flag to enable/disable free spins feature
export const normalBgColor = 0x2f4f4f;
export const freeSpinsBgColor = 0x4b0082;

// Derived constants (can also be calculated where needed, but useful here)
export const REEL_VISIBLE_HEIGHT = SYMBOLS_PER_REEL_VISIBLE * SYMBOL_SIZE;
export const reelAreaX = (GAME_WIDTH - NUM_REELS * REEL_WIDTH) / 2;
export const reelAreaY = 80; // Adjust as needed
export const bottomUIY = GAME_HEIGHT - 100; // Adjust as needed

// Background settings
export const BG_OFFSET_X = 0; // Horizontal offset adjustment
export const BG_OFFSET_Y = -20; // Move background up slightly to align with reels
export const BG_SCALE_MODE = 'cover'; // 'cover', 'contain', or 'exact'
export const BG_SCALE_FACTOR = 1.02; // Slight scale up to ensure full coverage
</file_content>

<file_content path="./src//config/paylines.js">
export const PAYLINES = [
  [1, 1, 1, 1, 1], // Line 1 (Middle row)
  [0, 0, 0, 0, 0], // Line 2 (Top row)
  [2, 2, 2, 2, 2], // Line 3 (Row below middle)
  [3, 3, 3, 3, 3], // Line 4 (Bottom row)
  [0, 1, 2, 1, 0], // Line 5 (V shape)
  [3, 2, 1, 2, 3], // Line 6 (Inverted V)
  [0, 1, 1, 1, 0], // Line 7
  [3, 2, 2, 2, 3], // Line 8
  [1, 2, 1, 0, 1], // Line 9
  [2, 1, 2, 3, 2], // Line 10
  [0, 0, 1, 2, 2], // Line 11
  [3, 3, 2, 1, 1], // Line 12
  [1, 0, 1, 2, 3], // Line 13
  [2, 3, 2, 1, 0], // Line 14
  [1, 2, 3, 2, 1], // Line 15
];

// Derived constant
export const NUM_PAYLINES = PAYLINES.length;
</file_content>

<file_content path="./src//config/symbolDefinitions.js">
export const SYMBOL_DEFINITIONS = [
  {
    id: "FACE1",
    color: 0xffd700,
    text: "(:",
    payout: { 3: 10, 4: 25, 5: 100 },
  },
  {
    id: "FACE2",
    color: 0x8b4513,
    text: "{:",
    payout: { 3: 8, 4: 20, 5: 80 },
  },
  {
    id: "FACE3",
    color: 0xde6fa1,
    text: "):",
    payout: { 3: 6, 4: 15, 5: 60 },
  },
  {
    id: "KNIFE",
    color: 0xa9a9a9,
    text: "K",
    payout: { 3: 4, 4: 10, 5: 40 },
  },
  {
    id: "CUP",
    color: 0xdc143c,
    text: "U",
    payout: { 3: 3, 4: 8, 5: 30 },
  },
  {
    id: "PATCH",
    color: 0x4682b4,
    text: "!",
    payout: { 3: 2, 4: 5, 5: 20 },
  },
  {
    id: "SCAT",
    color: 0xff00ff,
    text: "$",
    payout: { 3: 5, 4: 10, 5: 25 }, // Note: Scatter payout is often handled differently (any position)
  },
  {
    id: "LOW",
    color: 0x556b2f,
    text: "~",
    payout: { 3: 1, 4: 2, 5: 10 },
  },
];

// Derived Paytable for quick lookup
export const PAYTABLE = SYMBOL_DEFINITIONS.reduce((table, sym) => {
  if (sym.payout) table[sym.id] = sym.payout;
  return table;
}, {});
</file_content>

<file_content path="./src//config/animationSettings.js">
// Base settings (can be modified by Turbo Mode)
export let spinAcceleration = 0.1; // Increased from 0.05
export let maxSpinSpeed = 1.4; // Increased from 1.0
export let spinDeceleration = 0.92; // Increased deceleration for faster stop
export let minSpinSpeedBeforeSnap = 0.05;
export let stopDelayBase = 300; // Reduced initial delay
export let winAnimDelayMultiplier = 1.0;
export const REEL_STOP_STAGGER = 150; // Slower stagger for normal mode

// New settings for fixed duration + tween stop
export let baseSpinDuration = 1500; // Slower base duration for normal mode
export let stopTweenDuration = 250; // ms duration of the final tween into stop position

// Turbo settings modifiers (applied directly where needed)
export const turboSpinAcceleration = 0.15;
export const turboMaxSpinSpeed = 1.8;
// export const turboSpinDeceleration = 0.96; // No longer used by tween logic
// export const turboMinSpinSpeedBeforeSnap = 0.2; // No longer used by tween logic
// export const turboStopDelayBase = 100; // No longer used by tween logic
export const turboWinAnimDelayMultiplier = 0.2;
export const turboBaseSpinDuration = 500; // Faster duration for turbo
export const turboReelStopStagger = 50;   // Tighter stagger for turbo

// Bounce animation (Keep for reference, but skipBounce is unused now)
export const OVERSHOOT_AMOUNT = 0.15;
export const OVERSHOOT_DURATION = 120; // ms
export const BOUNCE_BACK_DURATION = 180; // ms
export let skipBounceInTurbo = true; // Configurable turbo behavior (Currently unused by tween logic)

// Removed updateAnimationSettings function - settings are applied directly based on state.isTurboMode
</file_content>

<file_content path="./src//config/reelStrips.js">
export const REEL_STRIPS = [
  [
    "FACE1",
    "KNIFE",
    "FACE2",
    "LOW",
    "CUP",
    "PATCH",
    "LOW", // Replace SCAT with LOW
    "FACE3",
    "LOW",
    "KNIFE",
    "PATCH",
    "FACE1",
    "LOW",
    "CUP",
    "FACE2",
    "SCAT",
  ],
  [
    "FACE2",
    "PATCH",
    "FACE3",
    "LOW",
    "KNIFE",
    "CUP",
    "FACE1",
    "LOW", // Replace SCAT with LOW
    "LOW",
    "FACE2",
    "PATCH",
    "KNIFE",
    "LOW",
    "FACE3",
    "CUP",
    "SCAT",
  ],
  [
    "FACE3",
    "CUP",
    "KNIFE",
    "LOW", // Replace SCAT with LOW
    "FACE1",
    "PATCH",
    "LOW",
    "FACE2",
    "KNIFE",
    "FACE3", // Corrected
    "LOW",   // Corrected
    "PATCH",
    "SCAT",
    "CUP",
    "FACE1",
    "LOW",
  ],
  [
    "FACE1",
    "LOW",
    "PATCH",
    "CUP",
    "FACE2",
    "KNIFE",
    "LOW", // Corrected
    "FACE3",
    "PATCH",
    "LOW",
    "FACE1",
    "CUP",
    "KNIFE",
    "FACE2",
    "LOW",
    "SCAT",
  ],
  [
    "SCAT",
    "FACE2",
    "LOW",
    "KNIFE",
    "FACE3",
    "CUP",
    "PATCH",
    "FACE1",
    "LOW",
    "KNIFE",
    "FACE2",
    "PATCH",
    "FACE3",
    "LOW",
    "CUP",
    "FACE1",
  ],
];
</file_content>

<file_content path="./src//features/FreeSpins.js">
import { FREE_SPINS_AWARDED, freeSpinsBgColor, normalBgColor } from '../config/gameSettings.js';
import { winAnimDelayMultiplier } from '../config/animationSettings.js';
import { state, updateState } from '../core/GameState.js'; // Assuming state management
import { showOverlayMessage } from '../ui/Notifications.js'; // Assuming notification handling
import { setButtonsEnabled, updateAutoplayButtonState, updateDisplays } from '../ui/UIManager.js'; // Import updateDisplays
import { startSpin } from '../ui/ButtonHandlers.js'; // Assuming spin initiation
import { gsap } from 'gsap'; // Import GSAP for animations
import * as PIXI from 'pixi.js'; // Import Pixi.js

// Reference to the Pixi app (needed for background color change)
let app = null;
let reelsContainer = null;
let reels = [];

// Free Spins state tracking
let freeSpinsRemaining = 0;
let freeSpinsTotalWin = 0;
const FREE_SPINS_MULTIPLIER = 2; // Multiplier for free spins wins

// Container for special animations during free spins
let specialAnimationsContainer = null;

/**
 * Initialize the free spins module
 * @param {PIXI.Application} pixiApp - Reference to the PIXI Application
 * @param {PIXI.Container} reelsContainerRef - Reference to the reels container
 * @param {Array} reelsRef - Array of reels
 */
export function initFreeSpins(pixiApp, reelsContainerRef, reelsRef) {
    app = pixiApp;
    reelsContainer = reelsContainerRef;
    reels = reelsRef;
    
    // Create container for special animations
    specialAnimationsContainer = new PIXI.Container();
    app.stage.addChild(specialAnimationsContainer);
}

/**
 * Enters the Free Spins mode.
 * Updates state, shows message, changes background, and starts the first free spin.
 * @param {number} spinsAwarded - Number of free spins to award (defaults to FREE_SPINS_AWARDED)
 */
export function enterFreeSpins(spinsAwarded = FREE_SPINS_AWARDED) {
    console.log(`Entering Free Spins mode with ${spinsAwarded} spins`);
    
    freeSpinsRemaining = spinsAwarded;
    freeSpinsTotalWin = 0;
    
    // Update game state
    updateState({ 
        isInFreeSpins: true, 
        freeSpinsRemaining: freeSpinsRemaining,
        totalFreeSpinsWin: 0
    });
    
    // Change background color with animation
    if (app && app.renderer) {
        gsap.to(app.renderer, {
            duration: 1.5,
            backgroundColor: freeSpinsBgColor,
            ease: "power2.inOut"
        });
    }
    
    // Play entry animation and show message
    playFreeSpinsEntryAnimation(() => {
        // Callback after animation completes
        showOverlayMessage(`${spinsAwarded} FREE SPINS AWARDED!`, 3000, () => {
            // Update UI elements
            updateDisplays();
            // Disable regular buttons since we're in auto mode
            setButtonsEnabled(false);
            // Start the first free spin automatically after the message
            setTimeout(() => {
                startFreeSpin();
            }, 500);
        });
    });
}

/**
 * Plays special entry animation for free spins
 * @param {Function} [onComplete] - Optional callback when animation completes
 */
function playFreeSpinsEntryAnimation(onComplete = () => {}) {
    updateState({ isTransitioning: true }); // Prevent actions during transition
    setButtonsEnabled(false); // Disable controls during animation
    
    // Create animation elements if container exists
    if (specialAnimationsContainer && app) {
        // Clear previous animations
        specialAnimationsContainer.removeChildren();
        
        // Create text styles
        const titleStyle = new PIXI.TextStyle({
            fontFamily: 'Impact, Charcoal, sans-serif',
            fontSize: 100,
            fontWeight: 'bold',
            fill: 0xFFD700, // Single gold color as hex number
            stroke: { color: 0x000000, width: 5 },
            dropShadow: { color: 0x000000, alpha: 0.7, blur: 5, distance: 3 },
            align: 'center'
        });
        
        // Create title text
        const title = new PIXI.Text("FREE SPINS", titleStyle);
        title.anchor.set(0.5);
        title.x = app.screen.width / 2;
        title.y = app.screen.height / 2;
        title.alpha = 0;
        title.scale.set(0.5);
        
        // Add to container
        specialAnimationsContainer.addChild(title);
        
        // Add shine effect
        const shine = new PIXI.Graphics();
        shine.beginFill(0xFFFFFF);
        shine.drawRect(-50, -title.height * 3, 100, title.height * 6);
        shine.endFill();
        shine.alpha = 0.7;
        shine.rotation = Math.PI / 4; // 45 degrees
        shine.x = -title.width;
        shine.y = app.screen.height / 2;
        shine.visible = false;
        specialAnimationsContainer.addChild(shine);
        
        // Animation sequence
        const tl = gsap.timeline({
            onComplete: () => {
                // Clean up and call the completion callback
                specialAnimationsContainer.removeChildren();
                onComplete(); // Will use empty function if not provided
            }
        });
        
        // Zoom in animation with bounce
        tl.to(title, {
            alpha: 1,
            scale: 1.2,
            duration: 0.5,
            ease: "back.out(1.7)"
        });
        
        // Add shine sweep effect
        tl.to(shine, {
            x: app.screen.width + 100,
            duration: 0.8,
            onStart: () => { shine.visible = true; },
            onComplete: () => { shine.visible = false; }
        }, "-=0.2");
        
        // Shrink and fade out
        tl.to(title, {
            scale: 0.8,
            alpha: 0,
            y: app.screen.height / 2 - 80,
            duration: 0.4,
            delay: 0.3
        });
    } else {
        // Fall back to simpler transition if container not available
        setTimeout(() => {
            if (onComplete) onComplete();
        }, 1000);
    }
}

/**
 * Initiates a single free spin if conditions are met.
 */
function startFreeSpin() {
    console.log("Attempting to start free spin:", {
        isInFreeSpins: state.isInFreeSpins,
        freeSpinsRemaining: state.freeSpinsRemaining,
        isSpinning: state.isSpinning,
        isTransitioning: state.isTransitioning
    });
    
    if (!state.isInFreeSpins) {
        console.error("Cannot start free spin: Not in free spins mode");
        return;
    }
    
    if (state.freeSpinsRemaining <= 0) {
        console.error("Cannot start free spin: No free spins remaining");
        return;
    }
    
    if (state.isSpinning) {
        console.error("Cannot start free spin: Already spinning");
        return;
    }
    
    if (state.isTransitioning) {
        console.error("Cannot start free spin: Game is in transition");
        return;
    }
    
    // Update UI to reflect current free spins state
    updateDisplays();
    
    // Ensure buttons remain disabled during free spins
    setButtonsEnabled(false);
    
    console.log("Starting free spin #" + (FREE_SPINS_AWARDED - state.freeSpinsRemaining + 1));
    
    // Call the main startSpin function, flagging it as a free spin
    startSpin(true);
}

/**
 * Exits the Free Spins mode.
 * Shows summary message, resets state, changes background back.
 */
export function exitFreeSpins() {
    if (!state.isInFreeSpins || !app) return;

    console.log(`Exit Free Spins. Total Win: €${state.totalFreeSpinsWin.toFixed(2)}`);
    updateState({ isTransitioning: true }); // Prevent actions during transition

    // Animate background color back to normal
    if (app.renderer && app.renderer.background) {
        const originalColor = app.renderer.background.color || freeSpinsBgColor;
        
        // Animate background color change
        const colorObj = { value: originalColor };
        gsap.to(colorObj, {
            value: normalBgColor,
            duration: 1,
            onUpdate: () => {
                app.renderer.background.color = Math.round(colorObj.value);
            }
        });
    }

    // Show summary message
    const winText = state.totalFreeSpinsWin > 0 ? 
        `FREE SPINS COMPLETE\nTOTAL WIN:\n€${state.totalFreeSpinsWin.toFixed(2)}` : 
        `FREE SPINS COMPLETE\nBETTER LUCK NEXT TIME!`;
    
    showOverlayMessage(
        winText,
        state.totalFreeSpinsWin > 0 ? 3000 : 2000, // Longer display for big wins
        () => {
            // Reset state AFTER the message
            updateState({
                isInFreeSpins: false,
                freeSpinsRemaining: 0,
                isTransitioning: false,
            });
            
            // Update UI to remove free spins indicators
            updateDisplays();
            
            // Re-enable controls
            setButtonsEnabled(true);
        }
    );
}

/**
 * Handles the logic after a free spin completes.
 * Updates total win, decrements remaining spins, and decides whether to start next spin or exit.
 */
export function handleFreeSpinEnd() {
    console.log("handleFreeSpinEnd called with state:", {
        isInFreeSpins: state.isInFreeSpins,
        freeSpinsRemaining: state.freeSpinsRemaining,
        lastTotalWin: state.lastTotalWin
    });
    
    if (!state.isInFreeSpins) {
        console.error("handleFreeSpinEnd: Not in free spins mode");
        return;
    }

    console.log(`Free spin completed. Spins remaining: ${state.freeSpinsRemaining - 1}`);
    
    // Apply multiplier to the win and add to total
    const multipliedWin = state.lastTotalWin * FREE_SPINS_MULTIPLIER;
    const totalWin = state.totalFreeSpinsWin + multipliedWin;
    
    console.log(`Win: ${state.lastTotalWin} x ${FREE_SPINS_MULTIPLIER} = ${multipliedWin}, Total: ${totalWin}`);
    
    // Update state with multiplied win
    updateState({ 
        totalFreeSpinsWin: totalWin,
        freeSpinsRemaining: state.freeSpinsRemaining - 1 
    });
    
    // Update UI to show current free spins state
    updateDisplays();

    // Delay before next action (next spin or exit)
    const delay = (state.isTurboMode ? 200 : 800) * winAnimDelayMultiplier;
    updateState({ isTransitioning: true });

    console.log(`Scheduling next action in ${delay}ms...`);
    
    setTimeout(() => {
        updateState({ isTransitioning: false });
        
        if (state.freeSpinsRemaining > 0) {
            console.log(`Starting next free spin. Remaining: ${state.freeSpinsRemaining}`);
            startFreeSpin(); // Start the next free spin
        } else {
            console.log("No more free spins remaining. Exiting free spins mode.");
            exitFreeSpins(); // No spins left, exit the mode
        }
    }, delay);
}

/**
 * Returns the current free spins multiplier for win calculations
 * @returns {number} - The multiplier value
 */
export function getFreeSpinsMultiplier() {
    return state.isInFreeSpins ? FREE_SPINS_MULTIPLIER : 1;
}
</file_content>

<file_content path="./src//features/TurboMode.js">
import { skipBounceInTurbo } from '../config/animationSettings.js'; // Removed updateAnimationSettings import
import { state } from '../core/GameState.js'; // Assuming state access
import { updateTurboButtonState as updateBtnState } from '../ui/UIManager.js'; // Assuming UI management

// Placeholder for reels data - this should be passed in or accessed via GameState/Game module
let reelsRef = [];
export function initTurboMode(reels) {
    reelsRef = reels;
}

/**
 * Applies turbo settings to the game.
 * Updates animation timings and reel bounce behavior based on the turbo state.
 * @param {boolean} isTurbo - Whether turbo mode is currently active.
 */
export function applyTurboSettings(isTurbo) {
    // updateAnimationSettings is removed as settings are now applied directly based on state.isTurboMode

    // Update reel-specific behavior if needed (like skipping bounce, though currently unused by tween logic)
    // This assumes reelsRef is initialized and contains reel objects with a 'skipBounce' property
    if (reelsRef && reelsRef.length > 0) {
        reelsRef.forEach(reel => {
            if (reel) { // Check if reel object exists
                reel.skipBounce = isTurbo && skipBounceInTurbo;
            } else {
                console.warn("TurboMode: Found undefined reel in reelsRef during applyTurboSettings.");
            }
        });
    } else {
        // This might happen if called before reels are created, maybe log a warning
        // console.warn("TurboMode: applyTurboSettings called before reelsRef was initialized or populated.");
    }

    // Update the button state visually (handled by UIManager)
    // updateBtnState(isTurbo); // Call the function imported from UIManager
}

// Note: updateTurboButtonState is now assumed to be part of UIManager.js
// It will read the `isTurboMode` from the shared state and update the button's appearance.
// The toggleTurbo function in ButtonHandlers.js calls applyTurboSettings here
// and then calls the UIManager's updateTurboButtonState.
</file_content>

<file_content path="./src//features/WinEvaluation.js">
import { PAYLINES, NUM_PAYLINES } from '../config/paylines.js';
import { PAYTABLE } from '../config/symbolDefinitions.js';
import {
    SCATTER_SYMBOL_ID, MIN_SCATTERS_FOR_FREE_SPINS, SYMBOLS_PER_REEL_VISIBLE,
    ENABLE_FREE_SPINS, FREE_SPINS_AWARDED
} from '../config/gameSettings.js';
import { state, updateState } from '../core/GameState.js'; // Assuming state management
import { drawWinLines } from './PaylineGraphics.js'; // Assuming graphics handling
import { playWinAnimations, animateWinningSymbols } from './Animations.js'; // Assuming animation handling
import { enterFreeSpins } from './FreeSpins.js'; // Assuming FreeSpins handling
import { updateDisplays } from '../ui/UIManager.js'; // Assuming UI update handling
// import { flashElement } from '../ui/Notifications.js'; // Assuming notification handling

// Placeholder for reels data - this should be passed in or accessed via GameState/Game module
let reelsRef = [];
export function initWinEvaluation(reels) {
    reelsRef = reels;
}

/**
 * Evaluates the win based on the current stopped reels.
 * Calculates line wins and scatter triggers.
 * Updates game state and triggers win animations/sounds.
 */
export function evaluateWin() {
    let calculatedTotalWin = 0;
    let calculatedWinningLines = []; // Initialize as empty array
    const resultsGrid = getResultsGrid();
    console.log("[DEBUG] WinEvaluation - Results Grid:", JSON.stringify(resultsGrid)); // DEBUG: Log the grid
    let scatterCount = 0;

    // --- Calculate Line Wins ---
    PAYLINES.forEach((linePath, lineIndex) => {
        // console.log(`--- [DEBUG] Checking Line ${lineIndex} --- Path: ${linePath}`); // DEBUG: Line Start
        let lineSymbolIds = [];
        let lineSymbolObjects = []; // Store references to the actual symbol objects on screen

        for (let reelIndex = 0; reelIndex < state.numReels; reelIndex++) { // Use state.numReels
            const rowIndex = linePath[reelIndex];
            if (rowIndex >= 0 && rowIndex < SYMBOLS_PER_REEL_VISIBLE) {
                const symbolId = resultsGrid[reelIndex][rowIndex];
                lineSymbolIds.push(symbolId);

                // Find the corresponding symbol object on the reel
                let symbolObj = null;
                const reel = reelsRef[reelIndex];
                if (reel && reel.symbols && reel.symbols.length > rowIndex + 1) {
                    symbolObj = reel.symbols[rowIndex + 1]; // Index 1 to SYMBOLS_PER_REEL_VISIBLE should be visible
                    console.log(`[DEBUG] Line ${lineIndex}, Reel ${reelIndex}, Row ${rowIndex}: Trying index ${rowIndex + 1}. Got symbolObj: ${symbolObj?.symbolId || 'undefined'}, Expected: ${symbolId}`);
                } else {
                     console.error(`[DEBUG] Line ${lineIndex}, Reel ${reelIndex}: Invalid reel or symbols array.`);
                }

                // Verify the retrieved object matches the expected symbol ID from the grid
                if (symbolObj && symbolObj.symbolId === symbolId) {
                    lineSymbolObjects.push(symbolObj);
                } else {
                    console.warn(`[DEBUG] Line ${lineIndex}, Reel ${reelIndex}, Row ${rowIndex}: Symbol object mismatch or missing (Expected: ${symbolId}, Found: ${symbolObj?.symbolId || 'null/undefined'}). Pushing null.`);
                    lineSymbolObjects.push(null);
                }
            } else {
                // Should not happen with valid PAYLINES definition
                lineSymbolIds.push(null);
                lineSymbolObjects.push(null);
            }
        }
        console.log(`[DEBUG] Line ${lineIndex} - Collected Symbol IDs: ${lineSymbolIds.join(', ')}`); // DEBUG: Symbols on line
        console.log(`[DEBUG] Line ${lineIndex} - Collected Symbol Objects:`, lineSymbolObjects.map(s => s?.symbolId || 'null')); // DEBUG: Symbol objects collected

        const firstSymbolId = lineSymbolIds[0];
        // console.log(`Line ${lineIndex} First Symbol: ${firstSymbolId}`); // DEBUG: First symbol
        if (!firstSymbolId || !PAYTABLE[firstSymbolId]) {
            // console.log(`Line ${lineIndex}: Skipping - First symbol invalid or not payable.`); // DEBUG
            return; // Skip if first symbol isn't payable
        }

        let matchCount = 1;
        for (let i = 1; i < state.numReels; i++) {
            if (lineSymbolIds[i] === firstSymbolId) {
                matchCount++;
            } else {
                break; // Symbols must match consecutively from the left
            }
        }
        console.log(`[DEBUG] Line ${lineIndex} - Calculated Match Count: ${matchCount}`); // DEBUG: Match count

        const payoutInfo = PAYTABLE[firstSymbolId];
        const expectedPayout = payoutInfo ? payoutInfo[matchCount] : undefined;
        // console.log(`Line ${lineIndex} Payout Info: ${JSON.stringify(payoutInfo)}, Expected Payout for ${matchCount}: ${expectedPayout}`); // DEBUG: Payout check

        if (matchCount >= 3 && payoutInfo && expectedPayout !== undefined) { // Check expectedPayout specifically
            const lineWin = expectedPayout * state.currentBetPerLine;
            calculatedTotalWin += lineWin;
            // Filter out nulls *before* slicing to ensure correct symbols are kept
            const validSymbolObjects = lineSymbolObjects.filter(s => s !== null);
            const winningSymbols = validSymbolObjects.slice(0, matchCount);

            const winInfo = {
                lineIndex: lineIndex,
                symbolId: firstSymbolId,
                count: matchCount, // Use the calculated matchCount
                winAmount: lineWin,
                symbols: winningSymbols, // Use the correctly sliced array
            };
            calculatedWinningLines.push(winInfo);
            console.log("[DEBUG] WinEvaluation - WIN FOUND:", {
                line: lineIndex,
                symbol: firstSymbolId,
                count: matchCount,
                amount: lineWin,
                symbolsToAnimate: winningSymbols.map(s => s.symbolId) // Log IDs being sent to animation
            });
        }
    });

    // --- Check for Scatters ---
    resultsGrid.forEach(col => col.forEach(symId => {
        if (symId === SCATTER_SYMBOL_ID) {
            scatterCount++;
        }
    }));

    // --- Update State and Trigger Effects ---
    updateState({ lastTotalWin: calculatedTotalWin, winningLinesInfo: calculatedWinningLines });

    if (calculatedTotalWin > 0) {
        if (!state.isInFreeSpins) {
            updateState({ balance: state.balance + calculatedTotalWin });
        }
        console.log(`Win: €${calculatedTotalWin.toFixed(2)}`);
        updateDisplays(); // Update balance/win text
        // flashElement(winText, 0xffff00, 200, 3); // Needs UIManager reference to winText
        drawWinLines(calculatedWinningLines); // Pass winning lines info
        playWinAnimations(calculatedTotalWin, state.currentTotalBet); // Pass win and bet for threshold checks
        
        // Collect all unique symbols to animate
        const allSymbolsToAnimate = [];
        const seenSymbols = new Set();
        
        calculatedWinningLines.forEach(info => {
            // Check the symbols array in the winInfo object passed to animation
            if (info.symbols && info.symbols.length > 0) {
                // Add only unique symbols to the animation array
                info.symbols.forEach(symbol => {
                    if (symbol && !seenSymbols.has(symbol)) {
                        seenSymbols.add(symbol);
                        allSymbolsToAnimate.push(symbol);
                    }
                });
                console.log(`[DEBUG] Collected ${info.symbols.length} symbols for line ${info.lineIndex}:`, info.symbols.map(s => s.symbolId));
            } else {
                console.warn(`[DEBUG] No valid symbols found to animate for line ${info.lineIndex}`);
            }
        });
        
        // Animate all winning symbols at once
        if (allSymbolsToAnimate.length > 0) {
            console.log(`[DEBUG] Animating ${allSymbolsToAnimate.length} unique symbols across all winning lines`);
            animateWinningSymbols(allSymbolsToAnimate);
        }
    } else {
        console.log("No line win.");
        updateDisplays(); // Ensure win display is cleared if needed
    }

    // --- Trigger Free Spins (if applicable and enabled) ---
    if (scatterCount >= MIN_SCATTERS_FOR_FREE_SPINS && ENABLE_FREE_SPINS) {
        console.log(`WinEvaluation: ${scatterCount} scatters found. Triggering free spins (Enabled: ${ENABLE_FREE_SPINS}).`);
        // Delay slightly after win animations if any
        const delay = (calculatedTotalWin > 0 ? 1000 : 100) * state.winAnimDelayMultiplier;
        updateState({ isTransitioning: true }); // Prevent actions during transition
        setTimeout(() => {
            import('../features/FreeSpins.js').then(module => {
                module.enterFreeSpins(FREE_SPINS_AWARDED); // Pass FREE_SPINS_AWARDED explicitly
            });
        }, delay);
    }
}

/**
 * Gets the grid of symbol IDs currently visible on the reels.
 * @returns {string[][]} A 2D array representing the visible grid [reelIndex][rowIndex].
 */
function getResultsGrid() {
    const grid = [];
    reelsRef.forEach((reel) => {
        const column = [];
        // Calculate visible symbols based on stopIndex
        // Ensure reel and strip exist
        if (reel && reel.strip) {
            for (let rowIndex = 0; rowIndex < SYMBOLS_PER_REEL_VISIBLE; rowIndex++) {
                // Ensure stopIndex is a number
                const stopIndex = typeof reel.stopIndex === 'number' ? reel.stopIndex : 0;
                const symbolIndexOnStrip = (stopIndex + rowIndex + reel.strip.length) % reel.strip.length;
                column.push(reel.strip[symbolIndexOnStrip]);
            }
        } else {
             console.error("[DEBUG] Invalid reel or reel strip found in getResultsGrid");
             // Push empty column or handle error appropriately
             for (let rowIndex = 0; rowIndex < SYMBOLS_PER_REEL_VISIBLE; rowIndex++) {
                 column.push(null); // Push nulls if reel is invalid
             }
        }
        grid.push(column);
    });
    // console.log("Result Grid:", grid); // Optional: Debugging
    return grid;
}
</file_content>

<file_content path="./src//features/SpriteSheetAnimations.js">
import * as PIXI from 'pixi.js';
import { gsap } from 'gsap';

// Store loaded sprite sheets
const loadedSpriteSheets = new Map();

/**
 * Loads and configures a sprite sheet for animation
 * 
 * @param {string} spriteSheetId - Unique identifier for this sprite sheet
 * @param {string} spriteSheetUrl - URL to the sprite sheet image
 * @param {object} spriteSheetData - Sprite sheet data (frames, animations)
 * @param {number} [fps=24] - Frames per second for animations
 * @returns {Promise<PIXI.Spritesheet>} - The loaded sprite sheet
 */
export async function loadSpriteSheet(spriteSheetId, spriteSheetUrl, spriteSheetData, fps = 24) {
    if (loadedSpriteSheets.has(spriteSheetId)) {
        console.log(`Sprite sheet ${spriteSheetId} already loaded`);
        return loadedSpriteSheets.get(spriteSheetId);
    }

    // Create a new sprite sheet
    const baseTexture = await PIXI.Assets.load(spriteSheetUrl);
    const spriteSheet = new PIXI.Spritesheet(baseTexture, spriteSheetData);
    
    // Parse the sprite sheet
    await spriteSheet.parse();
    
    // Store animation metadata with the sprite sheet
    spriteSheet.animationFps = fps;
    
    // Store for future use
    loadedSpriteSheets.set(spriteSheetId, spriteSheet);
    console.log(`Loaded sprite sheet: ${spriteSheetId}`);
    
    return spriteSheet;
}

/**
 * Creates an animated sprite using frames from a sprite sheet
 * 
 * @param {string} spriteSheetId - The ID of the previously loaded sprite sheet
 * @param {string} animationName - The animation sequence name
 * @param {boolean} [loop=true] - Whether the animation should loop
 * @returns {PIXI.AnimatedSprite|null} - The animated sprite or null if not found
 */
export function createAnimatedSprite(spriteSheetId, animationName, loop = true) {
    if (!loadedSpriteSheets.has(spriteSheetId)) {
        console.error(`Sprite sheet ${spriteSheetId} not loaded`);
        return null;
    }
    
    const spriteSheet = loadedSpriteSheets.get(spriteSheetId);
    
    // Get texture array for the animation
    let textures = [];
    
    // If the animationName is a specific animation sequence in the data
    if (spriteSheet.animations && spriteSheet.animations[animationName]) {
        textures = spriteSheet.animations[animationName];
    } else {
        // Try to find all textures with this prefix (e.g., "explosion_" + 0,1,2,3...)
        const prefix = `${animationName}_`;
        
        // Check if we have textures with this prefix
        let index = 0;
        let texture = spriteSheet.textures[`${prefix}${index}`];
        
        while (texture) {
            textures.push(texture);
            index++;
            texture = spriteSheet.textures[`${prefix}${index}`];
        }
        
        // If no textures found with number suffix, try to find a single frame
        if (textures.length === 0) {
            const singleTexture = spriteSheet.textures[animationName];
            if (singleTexture) {
                textures.push(singleTexture);
            }
        }
    }
    
    if (textures.length === 0) {
        console.error(`Animation "${animationName}" not found in sprite sheet ${spriteSheetId}`);
        return null;
    }
    
    // Create the animated sprite
    const animatedSprite = new PIXI.AnimatedSprite(textures);
    animatedSprite.animationSpeed = spriteSheet.animationFps / 60; // Convert FPS to PIXI's animation speed
    animatedSprite.loop = loop;
    
    return animatedSprite;
}

/**
 * Replaces a symbol with an animated sprite temporarily during win animations
 * 
 * @param {import('../core/Symbol.js').SymbolSprite} symbol - The symbol to replace with animation
 * @param {string} spriteSheetId - ID of the sprite sheet to use
 * @param {string} animationName - Name of the animation to play
 * @param {number} duration - Duration to show the animation (seconds)
 * @param {boolean} [keepOriginalScale=true] - Whether to maintain the original symbol's scale
 * @returns {Promise<void>} - Resolves when animation completes
 */
export async function playSpriteSheetAnimation(symbol, spriteSheetId, animationName, duration, keepOriginalScale = true) {
    return new Promise(resolve => {
        // Create animated sprite
        const animatedSprite = createAnimatedSprite(spriteSheetId, animationName, true);
        if (!animatedSprite) {
            resolve();
            return;
        }
        
        // Store original properties
        const parent = symbol.parent;
        const originalIndex = parent.getChildIndex(symbol);
        const originalX = symbol.x;
        const originalY = symbol.y;
        const originalScaleX = symbol.scale.x;
        const originalScaleY = symbol.scale.y;
        const originalVisible = symbol.visible;
        
        // Setup animated sprite
        animatedSprite.x = originalX;
        animatedSprite.y = originalY;
        animatedSprite.anchor.set(0.5, 0.5);
        
        if (keepOriginalScale) {
            animatedSprite.scale.set(originalScaleX, originalScaleY);
        }
        
        // Hide original symbol and show animation
        symbol.visible = false;
        parent.addChildAt(animatedSprite, originalIndex);
        animatedSprite.play();
        
        // Setup cleanup after animation finishes
        gsap.delayedCall(duration, () => {
            // Hide and remove animated sprite
            animatedSprite.stop();
            parent.removeChild(animatedSprite);
            
            // Restore original symbol
            symbol.visible = originalVisible;
            
            // Resolve the promise
            resolve();
        });
    });
}

/**
 * Creates a registration function for sprite-sheet based symbol animations
 * 
 * @param {string} spriteSheetId - The sprite sheet ID to use
 * @param {string} animationName - The animation name to play
 * @param {number} [duration=1.0] - Animation duration in seconds
 * @param {boolean} [keepOriginalSize=true] - Whether to maintain original symbol size
 * @returns {Function} - Animation function to register
 */
export function createSpriteSheetAnimationFn(spriteSheetId, animationName, duration = 1.0, keepOriginalSize = true) {
    return (symbol, timeline, config) => {
        // To avoid blocking the timeline, we'll run this as a side effect
        // and continue the regular timeline
        playSpriteSheetAnimation(
            symbol, 
            spriteSheetId, 
            animationName, 
            duration * config.duration, 
            keepOriginalSize
        );
        
        // Return the timeline so other effects can be chained
        return timeline;
    };
} </file_content>

<file_content path="./src//features/Animations.js">
import * as PIXI from 'pixi.js';
import { gsap } from 'gsap'; // Import GSAP
import { getWinRollupText } from '../ui/UIManager.js'; // Import function to get text element
import { winAnimDelayMultiplier } from '../config/animationSettings.js';
import { GAME_WIDTH, GAME_HEIGHT } from '../config/gameSettings.js';

// References to containers (need initialization)
let overlayContainer = null;
let particleContainer = null;
let winOverlayAnimInterval = null; // Interval ID for big win text animation
const particles = []; // Array to hold active particle objects

// Symbol Animation Registry - Maps symbol IDs to custom animation functions
const symbolAnimations = new Map();

/**
 * Registers a custom animation for a specific symbol type
 * 
 * @param {string} symbolId - The symbol identifier (e.g., "FACE1", "KNIFE")
 * @param {Function} animationFn - Function(symbol, baseTimeline, config) that adds custom animations to the timeline
 */
export function registerSymbolAnimation(symbolId, animationFn) {
    symbolAnimations.set(symbolId, animationFn);
    console.log(`Registered custom animation for symbol: ${symbolId}`);
}

/**
 * Initializes references to necessary PIXI containers.
 * @param {PIXI.Container} overlayCont - Container for big win text overlays.
 * @param {PIXI.Container} particleCont - Container for particle effects.
 */
export function initAnimations(overlayCont, particleCont) {
    if (!overlayCont || !particleCont) {
        console.error("Animations: Provided containers are invalid.");
        return;
    }
    overlayContainer = overlayCont;
    particleContainer = particleCont;
    console.log("Animations initialized with containers.");
    
    // Setup default symbol animations
    setupDefaultSymbolAnimations();
}

/**
 * Sets up the default symbol animations for various symbol types
 */
function setupDefaultSymbolAnimations() {
    // SCATTER symbol - special purple glow and extra scaling
    registerSymbolAnimation("SCAT", (symbol, tl, config) => {
        const goldPurple = 0xFF00FF;
        const targetScale = 1.4;  // Larger scale for scatter

        // Add a special purple/gold flash effect
        tl.to(symbol, {
            tint: goldPurple,
            duration: config.duration * 0.5,
            ease: "sine.inOut",
            repeat: 3,
            yoyo: true
        }, config.duration * 0.3);
        
        // Override the scale animation to be more dramatic
        tl.to(symbol.scale, {
            x: config.originalScaleX * targetScale,
            y: config.originalScaleY * targetScale,
            duration: config.duration * 0.5,
            ease: "back.out(1.5)"
        }, config.duration * 0.3);
        
        return tl;
    });
    
    // FACE1 (gold face) - gold shimmer effect
    registerSymbolAnimation("FACE1", (symbol, tl, config) => {
        const brightGold = 0xFFFF00;
        const dimGold = 0xDAA520;
        
        // Add a golden shimmer effect
        tl.to(symbol, {
            tint: brightGold,
            duration: config.duration * 0.3,
            repeat: 4,
            yoyo: true,
            ease: "sine.inOut"
        }, config.duration * 0.3);
        
        return tl;
    });
    
    // KNIFE - slashing rotation effect
    registerSymbolAnimation("KNIFE", (symbol, tl, config) => {
        const fullRotation = Math.PI * 2;
        
        // Add a full rotation effect
        tl.to(symbol, {
            rotation: config.originalRotation + fullRotation,
            duration: config.duration * 1.1,
            ease: "power3.inOut"
        }, config.duration * 0.4);
        
        return tl;
    });
}

/**
 * Animates the scale of winning symbols with a bounce effect.
 * @param {Array<import('../core/Symbol.js').SymbolSprite>} symbolsToAnimate - Array of SymbolSprite instances to animate.
 */
export function animateWinningSymbols(symbolsToAnimate) {
    if (!symbolsToAnimate || symbolsToAnimate.length === 0) return;

    const baseDuration = 0.35; // Increased base duration for longer animation
    const duration = baseDuration * winAnimDelayMultiplier;
    const targetScaleUp = 1.25; // Increased scale factor for more impact
    const initialDipScale = 0.9; // Deeper initial dip
    const easeType = "power2.out"; // Smoother ease out
    const easeBack = "elastic.out(1.2, 0.5)"; // More pronounced bounce

    // Track symbols by their unique ID to prevent duplicates
    const seenSymbols = new Set();
    
    symbolsToAnimate.forEach((symbol, index) => {
        // Skip if symbol is already being seen in this animation batch or is already animating
        if (!symbol?.scale || symbol.isAnimating || seenSymbols.has(symbol)) return;
        
        // Mark this symbol as seen in this animation batch
        seenSymbols.add(symbol);
        
        // Mark the symbol as animating to prevent multiple animations from running
        symbol.isAnimating = true;
        
        // Kill any existing tweens targeting this symbol or its scale
        gsap.killTweensOf(symbol);
        gsap.killTweensOf(symbol.scale);

        // Store original values
        const originalScaleX = symbol.scale.x;
        const originalScaleY = symbol.scale.y;
        const originalAlpha = symbol.alpha;
        const originalRotation = symbol.rotation;
        const originalTint = symbol.tint;
        
        // Add subtle staggered delay for sequential effect based on symbol index
        const staggerDelay = index * 0.08 * winAnimDelayMultiplier;
        
        // Create gold tint for winning effect - slot machine style
        const goldTint = 0xFFDF00; // Gold color
        
        // Configuration object to pass to custom animations
        const animConfig = {
            duration,
            originalScaleX,
            originalScaleY,
            originalAlpha,
            originalRotation,
            originalTint,
            targetScaleUp,
            initialDipScale,
            easeType,
            easeBack,
            goldTint
        };

        // Main animation timeline
        const tl = gsap.timeline({
            delay: staggerDelay,
            onComplete: () => {
                // Reset properties that might not be explicitly reset in the timeline
                symbol.tint = originalTint;
                symbol.alpha = originalAlpha;
                symbol.rotation = originalRotation;
                symbol.isAnimating = false;
            }
        });

        // Initial attention-grabbing quick flash - common to all symbols
        tl.to(symbol, { 
            alpha: 1.5, // Slight overbright
            duration: duration * 0.2, 
            ease: "power1.in",
        }, 0)
        
        // Initial dip with slight rotation - common to all symbols
        .to(symbol.scale, { 
            x: originalScaleX * initialDipScale, 
            y: originalScaleY * initialDipScale, 
            duration: duration * 0.3, 
            ease: "power2.in" 
        }, 0)
        .to(symbol, {
            rotation: originalRotation - 0.05,
            duration: duration * 0.3,
            ease: "power1.in"
        }, 0);
        
        // Check if this symbol has a custom animation
        const symbolId = symbol.symbolId;
        const customAnimation = symbolAnimations.get(symbolId);
        
        if (customAnimation) {
            // Apply the custom animation, which can override or extend the timeline
            customAnimation(symbol, tl, animConfig);
        } else {
            // Default animation sequence for symbols without custom animations
            tl.to(symbol.scale, { 
                x: originalScaleX * targetScaleUp, 
                y: originalScaleY * targetScaleUp, 
                duration: duration * 0.5, 
                ease: easeType 
            }, duration * 0.3)
            .to(symbol, {
                tint: goldTint,
                rotation: originalRotation + 0.08,
                duration: duration * 0.5,
                ease: "power1.out"
            }, duration * 0.3)
            
            // Pulsing phase - two subtle pulses while gold
            .to(symbol.scale, {
                x: originalScaleX * (targetScaleUp * 0.9),
                y: originalScaleY * (targetScaleUp * 0.9),
                duration: duration * 0.4,
                ease: "sine.inOut"
            }, duration * 0.8)
            .to(symbol.scale, {
                x: originalScaleX * targetScaleUp,
                y: originalScaleY * targetScaleUp,
                duration: duration * 0.4,
                ease: "sine.inOut"
            }, duration * 1.2)
            .to(symbol.scale, {
                x: originalScaleX * (targetScaleUp * 0.95),
                y: originalScaleY * (targetScaleUp * 0.95),
                duration: duration * 0.3,
                ease: "sine.inOut"
            }, duration * 1.6);
        }
        
        // Ensure all symbols return to original state at the end - common ending
        tl.to(symbol.scale, { 
            x: originalScaleX, 
            y: originalScaleY, 
            duration: duration * 0.8, 
            ease: easeBack 
        }, duration * 1.9)
        .to(symbol, {
            tint: originalTint,
            rotation: originalRotation,
            duration: duration * 0.8,
            ease: "power1.inOut"
        }, duration * 1.9);
    });
}

/**
 * Plays big/mega win text animations and triggers particle effects.
 * @param {number} winAmount - The total amount won in the spin.
 * @param {number} currentTotalBet - The total bet amount for the spin (for threshold calculation).
 */
export function playWinAnimations(winAmount, currentTotalBet) {
    const winRollupElement = getWinRollupText(); // Get the text element

    // --- Win Rollup Animation ---
    if (winRollupElement && winAmount > 0) {
        winRollupElement.text = `€0.00`; // Reset text
        winRollupElement.visible = true; // Make it visible
        winRollupElement.alpha = 1; // Ensure alpha is reset

        // Use a temporary object for GSAP to tween a numeric value
        const counter = { value: 0 };
        // Duration based on win amount, e.g., 0.5s for small wins up to 2s for large wins
        const rollupDuration = Math.max(0.5, Math.min(2.0, winAmount * 0.02));

        gsap.to(counter, {
            value: winAmount,
            duration: rollupDuration * winAnimDelayMultiplier, // Apply turbo multiplier
            ease: "power1.out",
            onUpdate: () => {
                if (winRollupElement) { // Check if element still exists
                    winRollupElement.text = `€${counter.value.toFixed(2)}`;
                }
            },
            onComplete: () => {
                // Optionally hide rollup after a delay, or let it stay until next spin starts
                // We'll hide it after 1.5 seconds delay
                 if (winRollupElement) {
                    gsap.to(winRollupElement, {
                        alpha: 0,
                        delay: 1.5 * winAnimDelayMultiplier,
                        duration: 0.3 * winAnimDelayMultiplier,
                        onComplete: () => { if (winRollupElement) winRollupElement.visible = false; }
                    });
                 }
            }
        });
    } else if (winRollupElement) {
        // Ensure rollup is hidden if there's no win
        winRollupElement.visible = false;
    }


    // --- Big/Mega Win Text Animation (Keep existing logic) ---
    if (!overlayContainer) {
        console.error("Animations: Overlay container not initialized for win animations.");
        return;
    }
    // Clear previous animation interval if any
    if (winOverlayAnimInterval) clearInterval(winOverlayAnimInterval);
    overlayContainer.removeChildren(); // Clear previous win text

    // Define win thresholds
    const bigWinThreshold = currentTotalBet * 10;
    const megaWinThreshold = currentTotalBet * 25;
    let winTextStr = "";

    // Determine win level text
    if (winAmount >= megaWinThreshold) winTextStr = "MEGA WIN!";
    else if (winAmount >= bigWinThreshold) winTextStr = "BIG WIN!";

    // --- Big/Mega Win Text Animation ---
    if (winTextStr) {
        const winOverlayText = new PIXI.Text({
            text: winTextStr + `\n€${winAmount.toFixed(2)}`,
            style: {
                fontFamily: "Impact, Charcoal, sans-serif",
                fontSize: 70,
                fill: 0xFFFF00, // Use single color instead of gradient array
                stroke: { color: 0x8B0000, width: 5 },
                dropShadow: { color: 0x000000, distance: 5, blur: 5, alpha: 0.8 },
                align: 'center',
            },
        });
        winOverlayText.anchor.set(0.5);
        winOverlayText.x = GAME_WIDTH / 2;
        winOverlayText.y = GAME_HEIGHT / 2 - 50; // Position slightly above center
        winOverlayText.scale.set(0.1); // Start small
        overlayContainer.addChild(winOverlayText);

        let scale = 0.1;
        let alpha = 1.0;
        let phase = 0; // 0: scaling up, 1: holding, 2: fading out
        let holdCounter = 0;
        const holdDuration = 50; // Frames/intervals to hold at full size
        const animSpeed = 20; // Interval speed (ms)

        winOverlayAnimInterval = setInterval(() => {
            if (!winOverlayText?.parent) { // Stop if text is removed
                clearInterval(winOverlayAnimInterval);
                return;
            }

            const currentAnimSpeed = animSpeed * winAnimDelayMultiplier; // Adjust speed for turbo

            if (phase === 0) { // Scaling up
                scale += 0.05 * (currentAnimSpeed / 20); // Adjust scale increment based on speed
                winOverlayText.scale.set(Math.min(1.0, scale));
                if (scale >= 1.0) {
                    phase = 1; // Move to hold phase
                    holdCounter = 0;
                }
            } else if (phase === 1) { // Holding
                holdCounter++;
                if (holdCounter * currentAnimSpeed >= holdDuration * 20) { // Adjust hold duration based on speed
                    phase = 2; // Move to fade out phase
                }
            } else if (phase === 2) { // Fading out
                alpha -= 0.04 * (currentAnimSpeed / 20); // Adjust alpha decrement
                winOverlayText.alpha = Math.max(0, alpha);
                if (alpha <= 0) {
                    clearInterval(winOverlayAnimInterval); // Stop animation
                    if (winOverlayText.parent) overlayContainer.removeChild(winOverlayText);
                    winOverlayText.destroy(); // Clean up
                }
            }
        }, animSpeed); // Base interval remains 20ms, logic adjusts based on multiplier
    }

    // --- Particle Effect ---
    // Trigger particles based on win amount relative to bet
    const numParticles = Math.min(60, Math.floor((winAmount / currentTotalBet) * 3));
    if (numParticles > 0) {
        createParticles(numParticles);
    }
}

/**
 * Creates a specified number of particle objects.
 * @param {number} count - The number of particles to create.
 */
function createParticles(count) {
    if (!particleContainer) {
        console.error("Animations: Particle container not initialized.");
        return;
    }
    for (let i = 0; i < count; i++) {
        const p = {
            gfx: new PIXI.Graphics()
                .circle(0, 0, Math.random() * 5 + 3) // Random size
                .fill({ color: Math.random() > 0.5 ? 0xffd700 : 0xf1c40f }), // Random gold/yellow
            vx: (Math.random() - 0.5) * 8, // Horizontal velocity
            vy: -Math.random() * 10 - 8, // Initial upward velocity
            gravity: 0.35,
            life: Math.random() * 80 + 40, // Lifetime in frames/updates
            alpha: 1.0,
        };
        p.fade = 1 / p.life; // Alpha fade per update
        // Start position around center
        p.gfx.x = GAME_WIDTH / 2 + (Math.random() - 0.5) * 100;
        p.gfx.y = GAME_HEIGHT / 2 + 50;
        particles.push(p);
        particleContainer.addChild(p.gfx);
    }
}

/**
 * Updates the position and state of all active particles.
 * Should be called in the main game loop.
 * @param {number} delta - Time delta since the last frame (usually from ticker).
 */
export function updateParticles(delta) {
    if (!particleContainer) return; // Don't run if not initialized

    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];

        // Apply physics
        p.vy += p.gravity * delta;
        p.gfx.x += p.vx * delta;
        p.gfx.y += p.vy * delta;

        // Update lifetime and alpha
        p.life -= delta;
        p.alpha -= p.fade * delta;
        p.gfx.alpha = Math.max(0, p.alpha);

        // Remove particle if life ended, faded out, or went off-screen
        if (p.life <= 0 || p.alpha <= 0 || p.gfx.y > GAME_HEIGHT + 20) {
            particleContainer.removeChild(p.gfx);
            p.gfx.destroy();
            particles.splice(i, 1); // Remove from active array
        }
    }
}
</file_content>

<file_content path="./src//features/Autoplay.js">
import { state, updateState } from '../core/GameState.js'; // Assuming state management
import { setButtonsEnabled, updateAutoplayButtonState as updateBtnState } from '../ui/UIManager.js'; // Assuming UI management
import { startSpin } from '../ui/ButtonHandlers.js'; // Assuming spin initiation
import { winAnimDelayMultiplier } from '../config/animationSettings.js';
import { NUM_PAYLINES } from '../config/paylines.js';
// import { flashElement } from '../ui/Notifications.js'; // Assuming notification handling

/**
 * Handles the logic for the next spin during autoplay.
 * Checks conditions (autoplay active, spins remaining, balance),
 * then schedules the next spin or stops autoplay.
 */
export function handleAutoplayNextSpin() {
    // Stop conditions
    if (!state.isAutoplaying || state.isInFreeSpins || state.isTransitioning) {
        if (state.isAutoplaying) { // Only log/update if it was actually autoplaying
            console.log("Autoplay stopped (condition met: FS/Transition).");
            updateState({ isAutoplaying: false, autoplaySpinsRemaining: 0 });
            updateBtnState(); // Update button appearance
            // updateInfoOverlay(); // Handled by UIManager
            // Enable buttons only if not transitioning into free spins or another state
            setButtonsEnabled(!state.isSpinning && !state.isInFreeSpins && !state.isTransitioning);
        }
        return;
    }

    if (state.autoplaySpinsRemaining > 0) {
        // Check balance before starting the next spin
        const currentTotalBet = state.currentBetPerLine * NUM_PAYLINES; // Recalculate just in case
        if (state.balance < currentTotalBet) {
            console.log("Autoplay stopped: Low balance.");
            updateState({ isAutoplaying: false, autoplaySpinsRemaining: 0 });
            updateBtnState();
            // updateInfoOverlay(); // Handled by UIManager
            setButtonsEnabled(true);
            // flashElement(balanceText, 0xe74c3c); // Needs UIManager reference
            return;
        }

        // Decrement spins and schedule next one
        updateState({ autoplaySpinsRemaining: state.autoplaySpinsRemaining - 1 });
        // updateInfoOverlay(); // Handled by UIManager

        const delay = (state.isTurboMode ? 150 : 600) * winAnimDelayMultiplier;
        updateState({ isTransitioning: true }); // Prevent actions during the short delay

        setTimeout(() => {
            updateState({ isTransitioning: false });
            startSpin(); // Start the next spin
        }, delay);

    } else {
        // Autoplay finished naturally
        console.log("Autoplay finished.");
        updateState({ isAutoplaying: false });
        updateBtnState();
        // updateInfoOverlay(); // Handled by UIManager
        setButtonsEnabled(true); // Re-enable buttons
    }
}

// Note: updateAutoplayButtonState is now assumed to be part of UIManager.js
// If it needs specific logic tied only to autoplay, it could live here,
// but updating button appearance feels like a UI Manager responsibility.
</file_content>

<file_content path="./src//features/AnimationDemo.js">
import { registerSymbolAnimation } from './Animations.js';
import { 
    loadSpriteSheet, 
    createSpriteSheetAnimationFn 
} from './SpriteSheetAnimations.js';
import * as PIXI from 'pixi.js';

/**
 * This file demonstrates how to register custom animations for symbols
 * Both using code-based animations and sprite-sheet animations
 */

/**
 * Register custom animations after the game has initialized
 */
export async function setupCustomAnimations() {
    console.log('Setting up custom animations...');
    
    // 1. CODE-BASED ANIMATIONS
    // These use GSAP and PIXI.js properties to create animations
    
    // Example: Add a custom PATCH animation with a flip effect
    registerSymbolAnimation("PATCH", (symbol, tl, config) => {
        // Add a 3D-like flip effect
        const midScale = { x: 0, y: config.originalScaleY * 1.2 };
        const finalScale = { x: config.originalScaleX * 1.2, y: config.originalScaleY * 1.2 };
        
        tl.to(symbol.scale, {
            x: 0,  // Squish horizontally to create "flip" effect
            y: config.originalScaleY * 1.2, // Slightly taller
            duration: config.duration * 0.4,
            ease: "power2.in"
        }, config.duration * 0.3)
        .to(symbol.scale, {
            x: config.originalScaleX * 1.2, // Return to width but enlarged
            y: config.originalScaleY * 1.2,
            duration: config.duration * 0.4,
            ease: "back.out(1.5)"
        }, config.duration * 0.7);
        
        return tl;
    });
    
    // Example: CUP animation with a "filling up" effect
    registerSymbolAnimation("CUP", (symbol, tl, config) => {
        // Red tint that pulses
        const redTint = 0xFF0000;
        
        tl.to(symbol, {
            tint: redTint,
            duration: config.duration * 0.3,
            ease: "power1.in"
        }, config.duration * 0.3)
        .to(symbol, {
            y: symbol.y - 10, // Move up slightly
            duration: config.duration * 0.5,
            repeat: 1,
            yoyo: true,
            ease: "power1.inOut"
        }, config.duration * 0.4);
        
        return tl;
    });
    
    // 2. FILTER-BASED ANIMATIONS
    // Using PIXI.js filters for advanced visual effects
    
    // Example: LOW symbol gets a cool blur-based "flowing" effect
    registerSymbolAnimation("LOW", (symbol, tl, config) => {
        // Create and add a displacement filter for warping effects
        const displacementSprite = PIXI.Sprite.from(PIXI.Texture.WHITE);
        displacementSprite.width = symbol.width * 2;
        displacementSprite.height = symbol.height * 2;
        displacementSprite.anchor.set(0.5);
        
        // These filter values needs to be tweaked based on your game's scale
        const displacementFilter = new PIXI.DisplacementFilter(displacementSprite);
        displacementFilter.scale.x = 0;
        displacementFilter.scale.y = 0;
        
        // Add filter to the symbol
        symbol.addFilter(displacementFilter, "waveDisplacement");
        
        // Add sprite to stage (required for displacement filter)
        if (symbol.parent) {
            symbol.parent.addChild(displacementSprite);
            displacementSprite.position.copyFrom(symbol.position);
        }
        
        // Animate the displacement effect
        tl.to(displacementFilter.scale, {
            x: 20, // How much horizontal displacement
            duration: config.duration * 0.5,
            ease: "sine.inOut"
        }, config.duration * 0.3)
        .to(displacementFilter.scale, {
            x: 0, // Return to normal
            duration: config.duration * 0.5,
            ease: "sine.inOut" 
        }, config.duration * 0.8);
        
        // Cleanup function at end of animation
        const currentOnComplete = tl.eventCallback("onComplete");
        tl.eventCallback("onComplete", () => {
            // Call original complete
            if (currentOnComplete) currentOnComplete();
            
            // Remove the displacement sprite
            if (displacementSprite.parent) {
                displacementSprite.parent.removeChild(displacementSprite);
            }
            displacementSprite.destroy();
            
            // Remove filter
            symbol.removeFilter("waveDisplacement");
        });
        
        return tl;
    });
    
    // Example: FACE2 gets a glow filter
    registerSymbolAnimation("FACE2", (symbol, tl, config) => {
        // Create a glow filter
        const glowFilter = new PIXI.BlurFilter();
        glowFilter.blur = 0;
        glowFilter.quality = 4; // Higher quality blur
        
        // Add filter to symbol
        symbol.addFilter(glowFilter, "glow");
        
        // Starting color - faded
        const startTint = 0xE0E0E0;
        
        // Animate the glow and color
        tl.to(symbol, {
            tint: config.goldTint, // Gold color
            duration: config.duration * 0.4,
            ease: "sine.inOut"
        }, config.duration * 0.3)
        .to(glowFilter, {
            blur: 10, // Increase blur to create glow
            duration: config.duration * 0.7,
            ease: "sine.out"
        }, config.duration * 0.3)
        .to(glowFilter, {
            blur: 0, // Fade out glow
            duration: config.duration * 0.6,
            ease: "sine.in"
        }, config.duration * 1.0);
        
        // Cleanup function
        const currentOnComplete = tl.eventCallback("onComplete");
        tl.eventCallback("onComplete", () => {
            // Call original complete
            if (currentOnComplete) currentOnComplete();
            
            // Remove the filter
            symbol.removeFilter("glow");
        });
        
        return tl;
    });
    
    // 3. SPRITE SHEET ANIMATIONS
    // First, we need to load the sprite sheets - this would typically happen
    // during the game's preloading phase
    try {
        // This is a hypothetical example - you'd need to create actual sprite sheets
        // Example sprite sheet for explosion effect
        /*
        const explosionSheet = await loadSpriteSheet(
            'explosion',
            'assets/spritesheets/explosion.png',
            {
                frames: {
                    "explosion_0": { frame: {x: 0, y: 0, w: 64, h: 64} },
                    "explosion_1": { frame: {x: 64, y: 0, w: 64, h: 64} },
                    // ... more frames ...
                },
                animations: {
                    explode: ["explosion_0", "explosion_1", /* etc... *//*]
                }
            },
            30 // 30 fps
        );
        
        // Register the sprite sheet animation for a symbol
        registerSymbolAnimation(
            "SCAT", // Scatter symbol gets explosion effect
            createSpriteSheetAnimationFn('explosion', 'explode', 0.8)
        );
        */
       
        console.log("Sprite sheet animations would load here if implemented");
    } catch (error) {
        console.error("Error loading sprite sheets:", error);
    }
}

/**
 * How to use sprite sheet animations in your game:
 * 
 * 1. Create sprite sheets using tools like TexturePacker, Aseprite, etc.
 * 2. Export sprite sheet image and JSON data
 * 3. Load sprite sheets during game initialization
 * 4. Register animations for specific symbols
 * 
 * Example sprite sheet structure (TexturePacker JSON Hash format):
 * 
 * {
 *   "frames": {
 *     "explosion_0": { "frame": {"x":0, "y":0, "w":64, "h":64} },
 *     "explosion_1": { "frame": {"x":64, "y":0, "w":64, "h":64} },
 *     ...
 *   },
 *   "animations": {
 *     "explode": ["explosion_0", "explosion_1", ...]
 *   }
 * }
 */

/**
 * To initialize all this in your game startup:
 * 
 * import { setupCustomAnimations } from './features/AnimationDemo.js';
 * 
 * // After game is initialized
 * setupCustomAnimations();
 */ </file_content>

<file_content path="./src//features/PaylineGraphics.js">
import * as PIXI from 'pixi.js';
import { winAnimDelayMultiplier } from '../config/animationSettings.js';
import { REEL_WIDTH, reelAreaX, reelAreaY } from '../config/gameSettings.js'; // Import positioning constants

// Reference to the graphics object (needs initialization)
let winLineGraphics = null;
let winLineFadeTimeout = null;
let winLineFadeInterval = null;

/**
 * Initializes the reference to the win line graphics object.
 * @param {PIXI.Graphics} graphics - The Pixi Graphics object for drawing lines.
 */
export function initPaylineGraphics(graphics) {
    if (!graphics) {
        console.error("PaylineGraphics: Provided graphics object is invalid.");
        return;
    }
    winLineGraphics = graphics;
    // Set initial position based on config (could also be done in Game setup)
    winLineGraphics.x = reelAreaX;
    winLineGraphics.y = reelAreaY;
    console.log("PaylineGraphics initialized with:", winLineGraphics);
}

/**
 * Draws the winning paylines based on the provided win information.
 * Includes fade-in and fade-out animations.
 * @param {Array} winningLinesInfo - Array of objects, each describing a winning line.
 *                                   Expected format: { lineIndex, count, symbols: [symbolObj1, ...] }
 */
export function drawWinLines(winningLinesInfo) {
    if (!winLineGraphics) {
        console.error("PaylineGraphics: Graphics object not initialized.");
        return;
    }
    if (!winningLinesInfo || winningLinesInfo.length === 0) {
        winLineGraphics.clear(); // Clear if no wins
        return;
    }

    // Clear previous animations/timeouts
    if (winLineFadeTimeout) clearTimeout(winLineFadeTimeout);
    if (winLineFadeInterval) clearInterval(winLineFadeInterval);
    winLineGraphics.clear();
    winLineGraphics.alpha = 0; // Start transparent for fade-in

    const lineColors = [ // Define colors for different lines
        0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff, 0xffa500,
        0x800080, 0x008000, 0x800000, 0xadd8e6, 0x90ee90, 0xffb6c1, 0xfaebd7, 0xdda0dd
    ];

    winningLinesInfo.forEach((info) => {
        if (!info.symbols || info.symbols.length < 1) return; // Skip if no symbols recorded

        const lineColor = lineColors[info.lineIndex % lineColors.length];
        winLineGraphics.lineStyle({ width: 5, color: lineColor, alpha: 0.7 });

        let firstValidPoint = true;
        for (let i = 0; i < info.count; i++) {
            const symbolObj = info.symbols[i];
            if (!symbolObj?.parent) { // Check if symbol is still valid and on stage
                console.warn(`PaylineGraphics: Symbol object invalid for line ${info.lineIndex}, index ${i}`);
                continue;
            }

            // Calculate position relative to the winLineGraphics container's origin (reelAreaX, reelAreaY)
            // Assumes symbolObj.parent is the reel container (rc)
            const reelIndex = symbolObj.parent.x / REEL_WIDTH; // Infer reel index from container position
            const symbolCenterX = reelIndex * REEL_WIDTH + REEL_WIDTH / 2;
            const symbolCenterY = symbolObj.y; // y position is relative to the reel container

            if (firstValidPoint) {
                winLineGraphics.moveTo(symbolCenterX, symbolCenterY);
                firstValidPoint = false;
            } else {
                winLineGraphics.lineTo(symbolCenterX, symbolCenterY);
            }
            // Draw circles at symbol centers
            winLineGraphics.drawCircle(symbolCenterX, symbolCenterY, 8).fill({ color: lineColor, alpha: 0.8 });
        }
        if (!firstValidPoint) {
            winLineGraphics.stroke(); // Draw the line segments
        }
    });

    // --- Fade In Animation ---
    let currentAlpha = 0;
    const fadeInDuration = 50 * winAnimDelayMultiplier; // Faster fade-in
    winLineFadeInterval = setInterval(() => {
        currentAlpha += 0.15; // Faster increment
        winLineGraphics.alpha = Math.min(0.8, currentAlpha);
        if (currentAlpha >= 0.8) {
            clearInterval(winLineFadeInterval);
        }
    }, fadeInDuration / (0.8 / 0.15)); // Adjust interval timing

    // --- Fade Out Timer ---
    const displayDuration = 3000 * winAnimDelayMultiplier;
    winLineFadeTimeout = setTimeout(() => {
        if (winLineFadeInterval) clearInterval(winLineFadeInterval); // Ensure fade-in stops

        let fadeOutAlpha = winLineGraphics.alpha;
        const fadeOutDuration = 50 * winAnimDelayMultiplier; // Faster fade-out
        const fadeOutInterval = setInterval(() => {
            fadeOutAlpha -= 0.15; // Faster decrement
            winLineGraphics.alpha = Math.max(0, fadeOutAlpha);
            if (fadeOutAlpha <= 0) {
                clearInterval(fadeOutInterval);
                winLineGraphics.clear(); // Clear graphics after fade out
            }
        }, fadeOutDuration / (fadeOutAlpha / 0.15 + 1)); // Adjust interval timing

    }, displayDuration);
}

/**
 * Clears any active win lines and stops animations.
 */
export function clearWinLines() {
    if (winLineFadeTimeout) clearTimeout(winLineFadeTimeout);
    if (winLineFadeInterval) clearInterval(winLineFadeInterval);
    if (winLineGraphics) {
        winLineGraphics.clear();
        winLineGraphics.alpha = 0;
    }
    winLineFadeTimeout = null;
    winLineFadeInterval = null;
}
</file_content>

<file_content path="./src//utils/helpers.js">
/**
 * Linearly interpolates between two angles, handling wrapping around a range (e.g., 360 degrees or 2*PI radians).
 * @param {number} start - The starting angle.
 * @param {number} end - The target angle.
 * @param {number} t - The interpolation factor (0 to 1).
 * @param {number} range - The full range of the angle (e.g., Math.PI * 2 for radians).
 * @returns {number} The interpolated angle.
 */
export function lerpAngle(start, end, t, range) {
    t = Math.max(0, Math.min(1, t)); // Clamp t between 0 and 1
    let delta = end - start;

    // Adjust delta if the shortest path wraps around the range
    if (Math.abs(delta) > range / 2) {
        delta -= Math.sign(delta) * range;
    }

    let result = start + delta * t;

    // Ensure the result stays within the valid range (e.g., 0 to range)
    return ((result % range) + range) % range;
}

/**
 * Easing function: quadratic ease-out.
 * Starts fast, then decelerates.
 * @param {number} t - Progress ratio (0 to 1).
 * @returns {number} Eased progress ratio.
 */
export const easeOutQuad = (t) => t * (2 - t);

// Add other general utility functions here if needed later.
</file_content>

<file_content path="./src//main.js">
import { Game } from './core/Game.js';

// --- Entry Point ---

// Wait for the DOM to be fully loaded
document.addEventListener('DOMContentLoaded', () => {
    // ID of the container element in index.html where the Pixi canvas will be added
    const gameContainerId = 'game-container'; // Make sure this ID exists in index.html

    // Create and initialize the game instance
    const game = new Game(gameContainerId);
    game.init().catch(err => {
        console.error("Failed to initialize game:", err);
        // Optionally display an error message to the user in the DOM
        const container = document.getElementById(gameContainerId);
        if (container) {
            container.innerHTML = `<p style="color: red; text-align: center; margin-top: 50px;">Error loading game. Please check console.</p>`;
        }
    });
});
</file_content>

<file_content path="./src//styles/main.css">
body {
  margin: 0;
  padding: 0;
  background-color: #1a1a1a;
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
  font-family: "Arial Black", Gadget, sans-serif;
  overflow: hidden;
}
canvas {
  border: 3px solid #b8860b;
  background-color: #2f4f4f;
  box-shadow: 0 0 25px rgba(0, 0, 0, 0.7);
}
.info-overlay {
  position: absolute;
  top: 10px;
  left: 10px;
  background: rgba(0, 0, 0, 0.7);
  color: #fff;
  padding: 5px 10px;
  border-radius: 5px;
  font-size: 14px;
  display: none;
  z-index: 10;
}
</file_content>

