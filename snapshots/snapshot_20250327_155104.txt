<file_content path="./src//ui/InfoOverlay.js">
// Placeholder import for game state
import { state } from '../core/GameState.js';

// Reference to the DOM element (needs to be initialized, perhaps in UIManager or Game)
let infoOverlayElement = null;

/**
 * Initializes the reference to the info overlay DOM element.
 * Should be called once during setup.
 * @param {HTMLElement} element - The DOM element for the info overlay.
 */
export function initInfoOverlay(element) {
    if (!element) {
        console.error("InfoOverlay: Provided element is invalid.");
        return;
    }
    infoOverlayElement = element;
    console.log("InfoOverlay initialized with element:", infoOverlayElement);
}

/**
 * Updates the content and visibility of the info overlay DOM element
 * based on the current game state (Autoplay, Free Spins).
 */
export function updateInfoOverlay() {
    if (!infoOverlayElement) {
        // console.warn("InfoOverlay: Element not initialized yet.");
        return; // Don't try to update if the element isn't set
    }

    let txt = "";
    if (state.isAutoplaying) {
        txt += `AUTOPLAY: ${state.autoplaySpinsRemaining}<br>`;
    }
    if (state.isInFreeSpins) {
        txt += `FREE SPINS: ${state.freeSpinsRemaining}<br>FS WIN: €${state.totalFreeSpinsWin.toFixed(2)}`;
    }

    if (txt) {
        infoOverlayElement.innerHTML = txt;
        infoOverlayElement.style.display = "block";
    } else {
        infoOverlayElement.innerHTML = ""; // Clear content when not needed
        infoOverlayElement.style.display = "none";
    }
}
</file_content>

<file_content path="./src//ui/ButtonHandlers.js">
/* global PIXI */ // Might be needed for flashing elements later
import { BET_PER_LINE_LEVELS } from '../config/gameSettings.js';
import { NUM_PAYLINES } from '../config/paylines.js'; // Corrected import
// Removed unused import: import { updateAnimationSettings } from '../config/animationSettings.js';

// --- Placeholder Imports (Will be replaced with actual module imports later) ---
// These represent dependencies that need to be resolved once other modules are created.
import { state, updateState } from '../core/GameState.js'; // Assuming GameState exports state object and update function
import { updateDisplays, updateAutoplayButtonState, updateTurboButtonState, setButtonsEnabled } from './UIManager.js'; // Assuming UIManager handles UI updates
import { flashElement } from './Notifications.js'; // Assuming Notifications handles flashing
import { applyTurboSettings as applyTurbo } from '../features/TurboMode.js'; // Assuming TurboMode handles applying settings
import { startSpinLoop } from '../core/Game.js'; // Assuming Game handles starting the spin process

// --- Bet Adjustment ---

function changeBet(direction) {
  // Access state via imported state object
  if (state.isSpinning || state.isTransitioning || state.isInFreeSpins) return;

  let currentLevelIndex = BET_PER_LINE_LEVELS.indexOf(state.currentBetPerLine);

  // Find closest level if current value isn't exact
  if (currentLevelIndex === -1) {
    currentLevelIndex = BET_PER_LINE_LEVELS.findIndex(
      (lvl) => lvl >= state.currentBetPerLine
    );
    if (currentLevelIndex === -1) {
      currentLevelIndex = BET_PER_LINE_LEVELS.length - 1;
    } else if (
      currentLevelIndex > 0 &&
      BET_PER_LINE_LEVELS[currentLevelIndex] > state.currentBetPerLine
    ) {
      currentLevelIndex--;
    }
  }

  let newLevelIndex = currentLevelIndex + direction;
  newLevelIndex = Math.max(
    0,
    Math.min(newLevelIndex, BET_PER_LINE_LEVELS.length - 1)
  );

  // Update state via imported function/object
  updateState({ currentBetPerLine: BET_PER_LINE_LEVELS[newLevelIndex] });
  updateState({ currentTotalBet: state.currentBetPerLine * NUM_PAYLINES }); // Also update total bet

  updateDisplays(); // Update UI
}

export function decreaseBet() {
  changeBet(-1);
}

export function increaseBet() {
  changeBet(1);
}

// --- Autoplay ---

export function toggleAutoplay() {
  if (state.isSpinning || state.isTransitioning || state.isInFreeSpins) return;

  if (state.isAutoplaying) {
    updateState({ isAutoplaying: false, autoplaySpinsRemaining: 0 });
    console.log("Autoplay stopped.");
    setButtonsEnabled(true); // Enable buttons
  } else {
    updateState({ isAutoplaying: true, autoplaySpinsRemaining: state.autoplaySpinsDefault }); // Use default from state
    console.log(`Autoplay started: ${state.autoplaySpinsRemaining} spins.`);
    updateAutoplayButtonState(); // Update button appearance
    startSpin(); // Start the first spin
  }
  // updateInfoOverlay(); // This will be handled by UIManager based on state changes
}


// --- Turbo Mode ---

export function toggleTurbo() {
  if (state.isTransitioning) return; // Prevent toggle during transitions

  const newTurboState = !state.isTurboMode;
  updateState({ isTurboMode: newTurboState }); // Update global state
  console.log(`Turbo: ${state.isTurboMode}`);

  // Apply settings (might involve updating animation config or directly passing values)
  applyTurbo(state.isTurboMode); // Call function from TurboMode feature
  updateTurboButtonState(); // Update button appearance
}


// --- Spin ---

export function startSpin(isFreeSpin = false) {
  if (state.isSpinning || state.isTransitioning) return;

  // Ensure total bet is current
  const currentTotalBet = state.currentBetPerLine * NUM_PAYLINES;
  updateState({ currentTotalBet: currentTotalBet });

  // Check balance only if it's not a free spin
  if (!isFreeSpin && state.balance < currentTotalBet) {
    console.warn("Insufficient funds.");
    // flashElement(balanceText, 0xe74c3c); // Needs reference to balanceText UI element - UIManager should handle this
    if (state.isAutoplaying) {
      // Stop autoplay if funds are insufficient
      updateState({ isAutoplaying: false, autoplaySpinsRemaining: 0 });
      updateAutoplayButtonState();
      // updateInfoOverlay(); // Handled by UIManager
    }
    setButtonsEnabled(true); // Re-enable buttons
    return; // Stop the spin process
  }

  // --- Start the Spin Process ---
  updateState({ isSpinning: true }); // Set master spinning flag
  setButtonsEnabled(false); // Disable controls

  // Reset win display and line graphics (UIManager or specific modules should handle this)
  updateState({ lastTotalWin: 0, winningLinesInfo: [] });
  // winLineGraphics.clear(); // Handled by PaylineGraphics module
  // overlayContainer.removeChildren(); // Handled by Notifications/UIManager

  updateDisplays(); // Update balance/win text immediately

  // Deduct bet if not a free spin
  if (!isFreeSpin) {
    updateState({ balance: state.balance - currentTotalBet });
    // balanceText.text = `€${state.balance.toFixed(2)}`; // Handled by UIManager
  }

  // Reset target stopping index for chained stops
  updateState({ targetStoppingReelIndex: 0 });

  // Initiate the actual reel spinning logic (call function in Game.js or ReelController.js)
  startSpinLoop(state.isTurboMode); // Pass turbo state if needed by the spin loop logic

  // The rest of the spin logic (scheduling stops, handling stop completion)
  // will be managed within the Game/Reel modules and the game loop itself.
}
</file_content>

<file_content path="./src//ui/UIManager.js">
import * as PIXI from 'pixi.js';
import { state } from '../core/GameState.js'; // Assuming state access
import { GAME_WIDTH, bottomUIY } from '../config/gameSettings.js';

// References to UI elements (Text objects, Buttons)
let uiContainerRef = null;
let balanceText = null;
let winText = null;
let betText = null;
let autoplayButton = null;
let turboButton = null;
let spinButton = null;
let betDecreaseButton = null;
let betIncreaseButton = null;
// Add other buttons if they need state management

/**
 * Initializes the UI Manager.
 * Creates text elements and stores references to them and the main UI container.
 * @param {PIXI.Container} uiContainer - The main container for UI elements.
 * @param {object} uiTextStyle - Style object for labels.
 * @param {object} uiValueStyle - Style object for value displays.
 */
export function initUIManager(uiContainer, uiTextStyle, uiValueStyle) {
    if (!uiContainer) {
        console.error("UIManager: Provided uiContainer is invalid.");
        return;
    }
    uiContainerRef = uiContainer;

    // --- Create Text Labels and Value Displays ---

    // Balance (Centered)
    const balanceLabel = new PIXI.Text({ text: "BALANCE", style: uiTextStyle });
    balanceLabel.anchor.set(0.5, 0); // Center anchor
    balanceLabel.x = GAME_WIDTH / 2; // Center X
    balanceLabel.y = bottomUIY + 15;
    balanceText = new PIXI.Text({ text: `€${state.balance.toFixed(2)}`, style: uiValueStyle });
    balanceText.anchor.set(0.5, 0); // Center anchor
    balanceText.x = GAME_WIDTH / 2; // Center X
    balanceText.y = bottomUIY + 40;
    uiContainer.addChild(balanceLabel, balanceText);

    // Win (Leave centered for now, maybe move later if needed)
    const winLabel = new PIXI.Text({ text: "WIN", style: uiTextStyle });
    winLabel.anchor.set(0.5, 0);
    winLabel.x = GAME_WIDTH / 2;
    winLabel.y = bottomUIY + 15;
    winText = new PIXI.Text({ text: `€${state.lastTotalWin.toFixed(2)}`, style: { ...uiValueStyle, fill: 0xf1c40f, fontSize: 26 } });
    winText.anchor.set(0.5, 0);
    winText.x = GAME_WIDTH / 2;
    winText.y = bottomUIY + 40;
    winText.visible = state.lastTotalWin > 0; // Initially hide if no win
    uiContainer.addChild(winLabel, winText);

    // Bet
    const betLabel = new PIXI.Text({ text: "BET", style: uiTextStyle });
    betLabel.anchor.set(1, 0);
    betLabel.x = GAME_WIDTH - 50;
    betLabel.y = bottomUIY + 15;
    betText = new PIXI.Text({ text: `€${state.currentTotalBet.toFixed(2)}`, style: uiValueStyle });
    betText.anchor.set(1, 0);
    betText.x = GAME_WIDTH - 50;
    betText.y = bottomUIY + 40;
    uiContainer.addChild(betLabel, betText);

    // --- Store Button References (assuming they are named in Game.js) ---
    // Buttons are added by ButtonFactory, find them by name
    spinButton = uiContainer.getChildByName("spinButton");
    autoplayButton = uiContainer.getChildByName("autoplayButton");
    turboButton = uiContainer.getChildByName("turboButton");
    betDecreaseButton = uiContainer.getChildByName("betDecreaseButton");
    betIncreaseButton = uiContainer.getChildByName("betIncreaseButton");

    if (!spinButton || !autoplayButton || !turboButton || !betDecreaseButton || !betIncreaseButton) {
         console.warn("UIManager: Could not find all expected buttons by name in uiContainer.");
    }

    console.log("UIManager initialized.");
}

/**
 * Updates the text displays (Balance, Bet, Win) based on the current game state.
 */
export function updateDisplays() {
    if (balanceText) balanceText.text = `€${state.balance.toFixed(2)}`;
    if (betText) betText.text = `€${state.currentTotalBet.toFixed(2)}`;
    if (winText) {
        winText.text = `€${state.lastTotalWin.toFixed(2)}`;
        winText.visible = state.lastTotalWin > 0;
    }
    // Update Info Overlay (DOM) - called separately by Game or state change listener
    // updateInfoOverlay();
}

/**
 * Enables or disables interaction and adjusts alpha for primary game buttons.
 * @param {boolean} enabled - True to enable, false to disable.
 */
export function setButtonsEnabled(enabled) {
    const alpha = enabled ? 1.0 : 0.5;
    const eventMode = enabled ? 'static' : 'none'; // Keep using string literals
    const cursor = enabled ? 'pointer' : 'default';

    const buttonsToToggle = [
        spinButton,
        autoplayButton,
        turboButton,
        betDecreaseButton,
        betIncreaseButton,
    ];

    buttonsToToggle.forEach(button => {
        if (!button) return; // Skip if button reference wasn't found

        // Special handling for bet buttons during free spins
        const isBetButton = button === betDecreaseButton || button === betIncreaseButton;
        const finalEnabled = enabled && !(isBetButton && state.isInFreeSpins);

        button.eventMode = finalEnabled ? 'static' : 'none'; // Keep using string literals
        button.alpha = finalEnabled ? 1.0 : 0.5;
        button.cursor = finalEnabled ? 'pointer' : 'default';

        // Reset visual state if disabling
        if (!finalEnabled && button.bgHover) {
             button.bgHover.visible = false;
             button.bgDown.visible = false;
             button.bgIdle.visible = true;
        }
    });

    // Update specific button states after general enable/disable
    updateAutoplayButtonState();
    updateTurboButtonState();
}

/**
 * Updates the visual state of the Autoplay button (text, color).
 */
export function updateAutoplayButtonState() {
    if (!autoplayButton) return;
    if (autoplayButton.buttonLabel) {
        autoplayButton.buttonLabel.text = state.isAutoplaying ? "■" : "▶"; // Square for stop, Play for start
    }
    // Update background tint if backgrounds are stored (e.g., button.bgIdle)
    if (autoplayButton.bgIdle) {
        const color = state.isAutoplaying ? 0xffa500 : 0x555555; // Orange when active
        autoplayButton.bgIdle.tint = color;
        // Ensure correct visibility if disabled/enabled changed state
        autoplayButton.bgIdle.visible = true;
        autoplayButton.bgHover.visible = false;
        autoplayButton.bgDown.visible = false;
    }
}

/**
 * Updates the visual state of the Turbo button (color).
 */
export function updateTurboButtonState() {
    if (!turboButton) return;
    // Update background tint if backgrounds are stored
    if (turboButton.bgIdle) {
        const color = state.isTurboMode ? 0x00ffff : 0x555555; // Cyan when active
        turboButton.bgIdle.tint = color;
         // Ensure correct visibility
        turboButton.bgIdle.visible = true;
        turboButton.bgHover.visible = false;
        turboButton.bgDown.visible = false;
    }
}
</file_content>

<file_content path="./src//ui/ButtonFactory.js">
import * as PIXI from 'pixi.js';
// Removed EventMode type import

/**
 * Creates a reusable PixiJS button component.
 * @param {string} text - The text label for the button (ignored if iconType is provided).
 * @param {number} x - The x-coordinate position.
 * @param {number} y - The y-coordinate position.
 * @param {function} callback - The function to call when the button is pressed.
 * @param {object} textStyleObject - PIXI.TextStyle properties (used only if no iconType).
 * @param {PIXI.Container} parentContainer - The container to add this button to. Required.
 * @param {number} [width=100] - The width of the button (used for radius if circular).
 * @param {number} [height=40] - The height of the button (used for radius if circular).
 * @param {boolean} [circular=false] - Whether the button should be circular.
 * @param {string} [iconType=undefined] - Optional: Type of icon to draw ('spin', etc.). If provided, text is ignored.
 * @returns {Button} The Button instance.
 */
export function createButton(
  text, x, y,
  callback,
  textStyleObject, // Still needed for potential non-icon buttons
  parentContainer,
  width = 100,
  height = 40,
  circular = false,
  iconType = undefined // Default to undefined
) {
   // Ensure callback is a function, provide a no-op default if not
   if (typeof callback !== "function") {
     console.warn("createButton: Callback provided is not a function. Using no-op.");
     callback = () => {};
   }

  // Pass iconType to the Button constructor
  const button = new Button(text, x, y, callback, textStyleObject, parentContainer, width, height, circular, iconType);

  // Add the button to the specified parent container
  // Note: Type error on addChild might persist if Button's eventMode type isn't perfectly aligned,
  // but the code should function correctly at runtime.
  if (parentContainer) {
      parentContainer.addChild(button);
  } else {
      console.warn("createButton: No parent container provided. Button not added to stage.");
  }

  return button; // Return the created button instance
}


/**
 * Represents a custom Button class extending PIXI.Container
 */
class Button extends PIXI.Container {
    buttonLabel; // Reference to the PIXI.Text label
    buttonIcon;  // Reference to the PIXI.Graphics icon
    bgIdle;      // Reference to idle background PIXI.Graphics
    bgHover;     // Reference to hover background PIXI.Graphics
    bgDown;      // Reference to down background PIXI.Graphics
    eventMode; // Declare without initializing

    constructor(
        text, x, y,
        callback,
        textStyleObject,
        parentContainer,
        width = 100,
        height = 40,
        circular = false,
        iconType // Remove default from constructor signature
    ) {
        super(); // Call PIXI.Container constructor

        // Ensure width and height are numbers
        width = Number(width) || 100;
        height = Number(height) || 40;
        // For circular buttons, use the smaller dimension to determine radius
        // For non-circular, use width/height as before
        const effectiveWidth = circular ? Math.min(width, height) : width;
        const effectiveHeight = circular ? Math.min(width, height) : height;
        const radius = effectiveWidth / 2; // Radius for circle or corner radius for rect

        // Set pivot to the center of the effective area
        this.pivot.set(effectiveWidth / 2, effectiveHeight / 2);
        this.x = x;
        this.y = y;
        this.eventMode = 'static'; // Initialize here
        this.cursor = "pointer";

        // --- Button Shapes ---
        const shape = new PIXI.Graphics();

        // Helper to draw the button shape
        const drawShape = (graphics, color, strokeColor) => {
            graphics.clear();
            if (circular) {
                graphics
                    .circle(radius, radius, radius) // Draw circle centered
                    .fill({ color: color })
                    .stroke({ width: 2, color: strokeColor, alignment: 0.5 });
            } else {
                // Keep rounded rect for non-circular buttons
                graphics
                    .roundRect(0, 0, width, height, 10) // Use fixed radius for consistency
                    .fill({ color: color })
                    .stroke({ width: 2, color: strokeColor, alignment: 0.5 });
            }
        };

        // Idle state background
        const bgIdle = shape.clone();
        drawShape(bgIdle, 0x555555, 0xaaaaaa);

        // Hover state background
        const bgHover = shape.clone();
        drawShape(bgHover, 0x777777, 0xcccccc);
        bgHover.visible = false;

        // Down state background
        const bgDown = shape.clone();
        drawShape(bgDown, 0x333333, 0x888888);
        bgDown.visible = false;

        // Add backgrounds first
        this.addChild(bgIdle, bgHover, bgDown);

        // --- Button Content (Icon or Text) ---
        if (iconType === 'spin') {
            const icon = new PIXI.Graphics();
            const iconRadius = radius * 0.6; // Make icon smaller than button
            const arrowThickness = radius * 0.15;
            const arrowColor = 0xffffff;

            // Draw two arcs for the spin icon
            icon.stroke({ width: arrowThickness, color: arrowColor, cap: 'round' }); // Use string 'round' for cap
            // Arc 1 (top-right to bottom-left) - Adjust angles for better appearance
            icon.arc(radius, radius, iconRadius, -Math.PI * 0.1, Math.PI * 0.9);
            // Draw arrowhead 1
            const angle1 = Math.PI * 0.9;
            const headLength = arrowThickness * 1.5;
            icon.moveTo(radius + iconRadius * Math.cos(angle1), radius + iconRadius * Math.sin(angle1));
            icon.lineTo(radius + iconRadius * Math.cos(angle1) - headLength * Math.cos(angle1 + Math.PI / 6), radius + iconRadius * Math.sin(angle1) - headLength * Math.sin(angle1 + Math.PI / 6));
            icon.moveTo(radius + iconRadius * Math.cos(angle1), radius + iconRadius * Math.sin(angle1));
            icon.lineTo(radius + iconRadius * Math.cos(angle1) - headLength * Math.cos(angle1 - Math.PI / 6), radius + iconRadius * Math.sin(angle1) - headLength * Math.sin(angle1 - Math.PI / 6));

            // Arc 2 (bottom-left to top-right) - Adjust angles
            icon.arc(radius, radius, iconRadius, Math.PI * 0.9, Math.PI * 1.9);
            // Draw arrowhead 2
            const angle2 = Math.PI * 1.9;
            icon.moveTo(radius + iconRadius * Math.cos(angle2), radius + iconRadius * Math.sin(angle2));
            icon.lineTo(radius + iconRadius * Math.cos(angle2) - headLength * Math.cos(angle2 + Math.PI / 6), radius + iconRadius * Math.sin(angle2) - headLength * Math.sin(angle2 + Math.PI / 6));
            icon.moveTo(radius + iconRadius * Math.cos(angle2), radius + iconRadius * Math.sin(angle2));
            icon.lineTo(radius + iconRadius * Math.cos(angle2) - headLength * Math.cos(angle2 - Math.PI / 6), radius + iconRadius * Math.sin(angle2) - headLength * Math.sin(angle2 - Math.PI / 6));

            this.buttonIcon = icon;
            this.addChild(icon);

        } else if (text) { // Only add text if no icon and text is provided
            const buttonText = new PIXI.Text({
                text: text,
                style: textStyleObject,
            });
            buttonText.anchor.set(0.5);
            buttonText.x = effectiveWidth / 2; // Center in the effective area
            buttonText.y = effectiveHeight / 2;
            this.buttonLabel = buttonText;
            this.addChild(buttonText);
        }

        // Store references to background states
        this.bgIdle = bgIdle;
        this.bgHover = bgHover;
        this.bgDown = bgDown;

        // --- Interaction Logic (Simplified - needs refinement for hover state after pointerup) ---
        this.on("pointerdown", () => {
            if (this.eventMode !== 'none') {
                 this.bgDown.visible = true;
                 this.bgIdle.visible = false;
                 this.bgHover.visible = false;
                 callback(); // Execute the provided callback
             }
         });

        this.on("pointerup", () => {
            if (this.eventMode !== 'none') {
                 this.bgDown.visible = false;
                 // TODO: Check if pointer is still over the button to show hover, otherwise show idle
                 // This requires access to the interaction manager or global pointer position,
                 // which is more complex. For now, just revert to idle.
                 this.bgIdle.visible = true;
                 this.bgHover.visible = false;
             }
         });

        this.on("pointerupoutside", () => {
            if (this.eventMode !== 'none') {
                 this.bgDown.visible = false;
                 this.bgIdle.visible = true;
                 this.bgHover.visible = false;
             }
         });

        this.on("pointerover", () => {
            if (this.eventMode !== 'none' && !this.bgDown.visible) {
                 this.bgHover.visible = true;
                 this.bgIdle.visible = false;
             }
         });

        this.on("pointerout", () => {
            // Only switch to idle if not currently in the down state
            if (this.eventMode !== 'none' && !this.bgDown.visible) {
                 this.bgHover.visible = false;
                 this.bgIdle.visible = true;
             }
         });
    }
}
</file_content>

<file_content path="./src//ui/Notifications.js">
import * as PIXI from 'pixi.js';
import { winAnimDelayMultiplier } from '../config/animationSettings.js';
import { GAME_WIDTH, GAME_HEIGHT } from '../config/gameSettings.js';

// Reference to the overlay container (needs initialization)
let overlayContainer = null;
let flashElementInterval = null; // Store interval ID for flashing

/**
 * Initializes the reference to the overlay container.
 * @param {PIXI.Container} container - The Pixi container for overlay messages.
 */
export function initNotifications(container) {
    if (!container) {
        console.error("Notifications: Provided overlay container is invalid.");
        return;
    }
    overlayContainer = container;
    console.log("Notifications initialized with container:", overlayContainer);
}

/**
 * Flashes a PixiJS display object (like Text) with a specific color.
 * @param {PIXI.Container} element - The Pixi element to flash (Container is a common base).
 * @param {number} [flashColor=0xff0000] - The color to flash (hex).
 * @param {number} [baseDuration=150] - Base duration of each flash phase (ms).
 * @param {number} [flashes=2] - Number of full on/off cycles.
 */
export function flashElement(
  element,
  flashColor = 0xff0000,
  baseDuration = 150,
  flashes = 2
) {
  if (flashElementInterval) clearInterval(flashElementInterval); // Clear previous interval
  if (!element?.parent) return; // Don't flash if element isn't on stage

  const originalTint = element.tint ?? 0xffffff;
  let count = 0;
  element.visible = true; // Ensure it's visible

  const duration = baseDuration * winAnimDelayMultiplier; // Adjust duration based on turbo

  function doFlash() {
    if (!element?.parent) { // Stop if element is removed
      clearInterval(flashElementInterval);
      return;
    }
    if (count >= flashes * 2) { // Completed all flashes
      clearInterval(flashElementInterval);
      element.tint = originalTint; // Restore original tint
      // Optionally hide if it's the win text and there's no win? Needs context.
      // if (element === winText && lastTotalWin <= 0) element.visible = false;
      return;
    }
    // Alternate between flash color and original tint
    element.tint = count % 2 === 0 ? flashColor : originalTint;
    count++;
  }

  doFlash(); // Start immediately
  flashElementInterval = setInterval(doFlash, duration);
}

/**
 * Displays a temporary message centered on the screen in the overlay container.
 * @param {string} message - The text message to display (use \n for newlines).
 * @param {number} duration - How long to display the message (ms).
 * @param {function} [callback] - Optional function to call after the message disappears.
 */
export function showOverlayMessage(message, duration, callback) {
  if (!overlayContainer) {
      console.error("Notifications: Overlay container not initialized.");
      return;
  }
  overlayContainer.removeChildren(); // Clear previous messages

  const messageStyle = {
    fontFamily: "Impact, Charcoal, sans-serif",
    fontSize: 60,
    fill: { // Define gradient fill explicitly
        gradient: 'linear',
        stops: [
            { offset: 0, color: 0xffffff }, // White
            { offset: 1, color: 0xdddddd }  // Light gray
        ]
    },
    stroke: { color: "#333333", width: 4 },
    dropShadow: { color: "#000", distance: 4, blur: 4 },
    align: 'center', // Use string literal
    lineSpacing: 10,
  };

  const messageText = new PIXI.Text({
    text: message,
    style: messageStyle,
  });
  messageText.anchor.set(0.5);
  messageText.x = GAME_WIDTH / 2;
  messageText.y = GAME_HEIGHT / 2;

  overlayContainer.addChild(messageText);

  // Use adjusted duration
  const displayDuration = duration * winAnimDelayMultiplier;

  setTimeout(() => {
    if (messageText.parent) { // Check if it hasn't been removed already
        overlayContainer.removeChild(messageText);
        messageText.destroy(); // Clean up Pixi object
    }
    if (callback) {
        callback(); // Execute callback if provided
    }
  }, displayDuration);
}
</file_content>

<file_content path="./src//core/Reel.js">
import * as PIXI from 'pixi.js';
import { SYMBOL_SIZE, SYMBOLS_PER_REEL_VISIBLE, REEL_WIDTH } from '../config/gameSettings.js';
import {
    spinAcceleration, maxSpinSpeed,
    stopTweenDuration // Import new setting
} from '../config/animationSettings.js'; // Import animation parameters
import { createSymbolGraphic } from './Symbol.js';
import { lerpAngle, easeOutQuad } from '../utils/helpers.js'; // Easing functions

export class Reel {
    constructor(reelIndex, strip, appTicker) {
        this.reelIndex = reelIndex;
        this.strip = strip;
        this.appTicker = appTicker; // Keep ticker reference if needed for 'now'

        this.container = new PIXI.Container();
        this.container.x = reelIndex * REEL_WIDTH;

        this.symbols = []; // Array of PIXI.Container symbol graphics
        this.position = Math.random() * this.strip.length; // Current position on the strip
        this.spinSpeed = 0;
        this.state = 'idle'; // idle, accelerating, spinning, tweeningStop, stopped
        this.stopIndex = 0; // Target index on the strip to stop at

        // Properties for scheduled stop tweening
        this.targetStopTime = 0; // Absolute time when the reel should finish stopping
        this.isTweeningStop = false;
        this.tweenStartTime = 0;
        this.tweenStartPosition = 0;
        this.finalStopPosition = 0; // Store the target stop index as final position

        // Blur filter
        this.blur = new PIXI.BlurFilter({ strength: 0, quality: 1, kernelSize: 5 });
        this.blur.enabled = false;
        this.container.filters = [this.blur];

        // Create initial symbols
        const numSymbolsToCreate = SYMBOLS_PER_REEL_VISIBLE + 2; // +2 for buffer top/bottom
        for (let j = 0; j < numSymbolsToCreate; j++) {
            const symbol = createSymbolGraphic(this.strip[0]); // Start with placeholder
            this.symbols.push(symbol);
            this.container.addChild(symbol);
        }
        this.alignReelSymbols(); // Position initial symbols correctly
    }

    // --- Reel State Control ---

    startSpinning(currentTurbo) {
        this.state = 'accelerating';
        this.spinSpeed = 0; // Start from 0 speed
        this.blur.enabled = true;
        this.blur.strength = 0;
        // Determine random stop index (can be overridden by server/predetermined results later)
        this.stopIndex = Math.floor(Math.random() * this.strip.length);
        this.finalStopPosition = this.stopIndex; // Store the target index
        this.isTweeningStop = false; // Reset tweening state
        this.targetStopTime = 0; // Reset target stop time
        console.log(`Reel ${this.reelIndex}: Starting spin, target stop index: ${this.stopIndex}`);
    }

    // New method to schedule the stop
    scheduleStop(targetStopTime) {
        this.targetStopTime = targetStopTime;
        // The actual transition to tweening will happen in the update loop based on time
    }

    // --- Symbol Alignment ---

    alignReelSymbols() {
        const totalStripSymbols = this.strip.length;
        const numSymbolsInDisplay = this.symbols.length; // Should be SYMBOLS_PER_REEL_VISIBLE + 2

        for (let j = 0; j < numSymbolsInDisplay; j++) {
            const symbol = this.symbols[j];
            if (!symbol) continue;

            const currentTopSymbolIndex = Math.floor(this.position) % totalStripSymbols;
            const symbolOffset = this.position - Math.floor(this.position);
            const targetStripIndex = (currentTopSymbolIndex + (j - 1) + totalStripSymbols) % totalStripSymbols;

            symbol.y = (j - 1 - symbolOffset) * SYMBOL_SIZE + SYMBOL_SIZE / 2;

            const expectedSymbolId = this.strip[targetStripIndex];
            if (!symbol.symbolId || symbol.symbolId !== expectedSymbolId) {
                const oldSymbolY = symbol.y;
                this.container.removeChild(symbol);
                symbol.destroy({ children: true });

                const newSymbol = createSymbolGraphic(expectedSymbolId);
                if (newSymbol) {
                    newSymbol.y = oldSymbolY;
                    newSymbol.scale.set(1);
                    this.symbols[j] = newSymbol;
                    this.container.addChild(newSymbol);
                }
            }
        }
    }

    // --- Update Logic (Called by Game Loop) ---

    update(delta, now) { // 'now' is the current time from the ticker (performance.now() or similar)
        let needsAlign = false;
        let reelIsActive = true; // Assume active unless stopped/idle

        // Check if it's time to start the stop tween
        if ((this.state === 'accelerating' || this.state === 'spinning') && this.targetStopTime > 0 && now >= this.targetStopTime - stopTweenDuration) {
            this.state = 'tweeningStop';
            this.isTweeningStop = true;
            this.tweenStartTime = now;
            // Ensure position is wrapped correctly before starting tween
            this.position = ((this.position % this.strip.length) + this.strip.length) % this.strip.length;
            this.tweenStartPosition = this.position;
            this.spinSpeed = 0; // Stop applying speed changes
            this.blur.strength = 0; // Start reducing blur (or turn off instantly)
            this.blur.enabled = false; // Turn off blur for stop tween
            console.log(`Reel ${this.reelIndex}: Starting stop tween at ${now.toFixed(0)}ms`);
        }

        switch (this.state) {
            case 'accelerating':
                this.spinSpeed = Math.min(maxSpinSpeed, this.spinSpeed + spinAcceleration * delta);
                this.position += this.spinSpeed * delta;
                if (this.spinSpeed >= maxSpinSpeed) {
                    this.state = 'spinning';
                    this.spinSpeed = maxSpinSpeed; // Cap speed
                }
                this.blur.strength = (this.spinSpeed / maxSpinSpeed) * 8;
                needsAlign = true;
                break;

            case 'spinning':
                // Continue spinning at max speed
                this.position += maxSpinSpeed * delta;
                this.blur.strength = 8; // Max blur
                needsAlign = true;
                break;

            case 'tweeningStop':
                if (this.isTweeningStop) {
                    const elapsed = now - this.tweenStartTime;
                    let progress = Math.min(1, elapsed / stopTweenDuration); // Clamp progress 0-1

                    // Apply easing function (e.g., easeOutQuad)
                    progress = easeOutQuad(progress);

                    // Interpolate angle correctly, handling wrap-around
                    this.position = lerpAngle(this.tweenStartPosition, this.finalStopPosition, progress, this.strip.length);
                    needsAlign = true;

                    if (progress === 1) { // Tween completed
                        this.isTweeningStop = false;
                        this.position = this.finalStopPosition; // Ensure exact final position
                        this.state = 'stopped';
                        needsAlign = true; // Final alignment
                        reelIsActive = false; // Mark as stopped
                        console.log(`Reel ${this.reelIndex}: Stopped at ${now.toFixed(0)}ms`);
                    }
                }
                break;

            // Remove old 'stopping' and 'BOUNCING' states

            case 'stopped':
            case 'idle':
                reelIsActive = false;
                // Ensure blur is off
                if (this.blur.enabled) {
                    this.blur.enabled = false;
                    this.blur.strength = 0;
                }
                break;
        } // End Switch

        // Normalize position and align symbols if needed
        if (needsAlign) {
            // Wrap position around strip length
            this.position = ((this.position % this.strip.length) + this.strip.length) % this.strip.length;
            this.alignReelSymbols();
        }

        return reelIsActive; // Return whether the reel is still considered moving/active
    }
}
</file_content>

<file_content path="./src//core/Game.js">
import * as PIXI from 'pixi.js';
import * as SETTINGS from '../config/gameSettings.js';
import { REEL_STRIPS } from '../config/reelStrips.js';
// Import animation settings
import {
    // stopDelayBase, // No longer used directly here
    winAnimDelayMultiplier, // Still used in handleSpinEnd
    REEL_STOP_STAGGER, baseSpinDuration, stopTweenDuration, // Normal settings
    turboBaseSpinDuration, turboReelStopStagger // Turbo settings
} from '../config/animationSettings.js';
import { state, updateState, initGameState } from './GameState.js';
import { Reel } from './Reel.js';
import { createButton } from '../ui/ButtonFactory.js';
import * as handlers from '../ui/ButtonHandlers.js';
import { initInfoOverlay, updateInfoOverlay } from '../ui/InfoOverlay.js';
import { initNotifications } from '../ui/Notifications.js'; // init only
import { initWinEvaluation, evaluateWin } from '../features/WinEvaluation.js';
import { initPaylineGraphics, clearWinLines } from '../features/PaylineGraphics.js'; // Import clearWinLines here
import { initFreeSpins } from '../features/FreeSpins.js';
import { initTurboMode, applyTurboSettings } from '../features/TurboMode.js';
import { initAnimations, updateParticles } from '../features/Animations.js'; // Import updateParticles here
import { initUIManager, updateDisplays, setButtonsEnabled } from '../ui/UIManager.js'; // Assuming UIManager exists
import { handleAutoplayNextSpin } from '../features/Autoplay.js';

// --- Module-level variables ---
let app = null;
let reels = [];
let reelContainer, uiContainer, winLineGraphics, overlayContainer, particleContainer;
let infoOverlayElement; // DOM element reference

// --- Game Class ---
export class Game {
    constructor(canvasContainerId) {
        this.canvasContainer = document.getElementById(canvasContainerId);
        if (!this.canvasContainer) {
            console.error(`Game Error: Canvas container #${canvasContainerId} not found.`);
            return;
        }
        // Initialize game state with default values
        initGameState();
    }

    async init() {
        try {
            // --- PixiJS App Setup ---
            app = new PIXI.Application();
            await app.init({
                width: SETTINGS.GAME_WIDTH,
                height: SETTINGS.GAME_HEIGHT,
                backgroundColor: SETTINGS.normalBgColor,
                resolution: window.devicePixelRatio || 1,
                autoDensity: true,
            });
            // Ensure app and canvas exist before appending
            if (app?.canvas && this.canvasContainer) {
                this.canvasContainer.appendChild(app.canvas);
            } else {
                throw new Error("Pixi Application or canvas could not be initialized.");
            }

            // --- Initialize Core Modules ---
            initFreeSpins(app); // Pass app reference for background changes

            // --- Create Main Containers ---
            reelContainer = new PIXI.Container();
            reelContainer.x = SETTINGS.reelAreaX;
            reelContainer.y = SETTINGS.reelAreaY;
            // Ensure app and stage exist before adding children
            if (!app?.stage) throw new Error("Pixi stage not available after init.");
            app.stage.addChild(reelContainer);

            uiContainer = new PIXI.Container();
            app.stage.addChild(uiContainer); // Add UI container first? Or last? Check layering.

            winLineGraphics = new PIXI.Graphics();
            // Position set in initPaylineGraphics
            app.stage.addChild(winLineGraphics);

            overlayContainer = new PIXI.Container(); // For win messages, etc.
            app.stage.addChild(overlayContainer);

            particleContainer = new PIXI.Container(); // For particle effects
            app.stage.addChild(particleContainer);

            // --- Initialize Feature/UI Modules with Containers ---
            initPaylineGraphics(winLineGraphics);
            initNotifications(overlayContainer); // Pass overlay container
            initAnimations(overlayContainer, particleContainer); // Pass relevant containers
            initTurboMode(reels); // Pass reels array reference

            // --- Create Reels ---
            for (let i = 0; i < SETTINGS.NUM_REELS; i++) {
                const reel = new Reel(i, REEL_STRIPS[i], app.ticker);
                reels.push(reel);
                reelContainer.addChild(reel.container);
            }
            initWinEvaluation(reels); // Pass reels array reference

            // --- Reel Mask ---
            const reelMask = new PIXI.Graphics()
                .rect(SETTINGS.reelAreaX, SETTINGS.reelAreaY, SETTINGS.NUM_REELS * SETTINGS.REEL_WIDTH, SETTINGS.REEL_VISIBLE_HEIGHT)
                .fill(0xffffff);
            reelContainer.mask = reelMask;
            if (app?.stage) { // Check again before adding mask
               app.stage.addChild(reelMask); // Mask needs to be added to stage
            }

            // --- Setup UI ---
            this.setupUI(); // Call UI setup method

            // --- Initialize Info Overlay (DOM) ---
            infoOverlayElement = document.getElementById('infoOverlay'); // Get DOM element
            if (infoOverlayElement) {
                initInfoOverlay(infoOverlayElement); // Initialize the module
                updateInfoOverlay(); // Initial update
            } else {
                console.warn("Game Setup: infoOverlay element not found in DOM.");
            }

            // --- Final Setup ---
            updateDisplays(); // Initial UI text update
            setButtonsEnabled(true); // Enable buttons initially
            applyTurboSettings(state.isTurboMode); // Apply initial turbo settings

            // --- Start Game Loop ---
            // Ensure app and ticker exist before adding update loop
            if (app?.ticker) {
                app.ticker.add(this.update.bind(this)); // Add bound update method to ticker
            } else {
                 throw new Error("Pixi ticker not available after init.");
            }

            console.log("Game Initialized Successfully");

        } catch (err) {
            console.error("PixiJS or Game Init Failed:", err);
            this.canvasContainer.innerHTML = `Error initializing graphics: ${err.message}. Check console.`;
        }
    }

    setupUI() {
        // --- Title ---
        const titleStyle = {
             fontFamily: "Impact, Charcoal, sans-serif",
             fontSize: 40,
             // Use a single color for fill as PixiJS expects
             fill: 0xffd700, // Gold color
             stroke: { color: "#8B0000", width: 3 },
             dropShadow: { color: "#000000", distance: 4, blur: 4, angle: Math.PI / 4, alpha: 0.7 }
            };
        const titleText = new PIXI.Text({ text: "HEAVENS TEN", style: titleStyle });
        titleText.anchor.set(0.5, 0);
        titleText.x = SETTINGS.GAME_WIDTH / 2;
        titleText.y = 15;
        // Ensure app and stage exist before adding title
        if (app && app.stage) { // More explicit check
            app.stage.addChild(titleText); // Add title directly to stage
        }

        // --- UI Panel ---
        const panelHeight = 100;
        const panel = new PIXI.Graphics()
            .rect(0, SETTINGS.GAME_HEIGHT - panelHeight, SETTINGS.GAME_WIDTH, panelHeight)
            .fill({ color: 0x1a1a1a, alpha: 0.8 });
        uiContainer.addChild(panel);

        // --- Text Styles ---
        const uiTextStyle = { fontFamily: "Arial, sans-serif", fontSize: 18, fill: 0xdddddd };
        const uiValueStyle = { fontFamily: '"Arial Black", Gadget, sans-serif', fontSize: 22, fill: 0xffffff, stroke: { color: 0x000000, width: 2 } };
        const buttonTextStyle = { fontFamily: '"Arial Black", Gadget, sans-serif', fontSize: 20, fill: 0xffffff };

        // --- Create UI Elements (using UIManager) ---
        // UIManager should handle creation and storing references
        initUIManager(uiContainer, uiTextStyle, uiValueStyle);

        // --- Create Buttons (using ButtonFactory and handlers) ---
        const bottomUIY = SETTINGS.bottomUIY;
        const btnW = 40, btnH = 40; // Common button size

        // Bet Buttons
        createButton("-", SETTINGS.GAME_WIDTH - 200, bottomUIY + 55, handlers.decreaseBet, buttonTextStyle, uiContainer, btnW, btnH).name = "betDecreaseButton";
        createButton("+", SETTINGS.GAME_WIDTH - 140, bottomUIY + 55, handlers.increaseBet, buttonTextStyle, uiContainer, btnW, btnH).name = "betIncreaseButton";

        // Spin Button (Circular with Icon)
        // Note: Text '↻' and textStyle are now ignored due to iconType='spin'
        createButton("↻", SETTINGS.GAME_WIDTH - 75, SETTINGS.GAME_HEIGHT / 2 + 50, handlers.startSpin, {}, uiContainer, 80, 80, true, 'spin').name = "spinButton";

        // Turbo Button
        createButton("⚡", 90 + 20, bottomUIY + 55, handlers.toggleTurbo, buttonTextStyle, uiContainer, btnW, btnH).name = "turboButton";

        // Autoplay Button
        createButton("▶", 150 + 20, bottomUIY + 55, handlers.toggleAutoplay, buttonTextStyle, uiContainer, btnW, btnH).name = "autoplayButton";

        // Placeholder/Inactive Buttons
        createButton("$", SETTINGS.GAME_WIDTH - 75, SETTINGS.GAME_HEIGHT / 2 - 50, () => {}, buttonTextStyle, uiContainer, 60, 60, true).alpha = 0.3;
        createButton("☰", SETTINGS.GAME_WIDTH - 55, 20 + 20, () => {}, buttonTextStyle, uiContainer, btnW, btnH).alpha = 0.3;
        // Removed overlapping 'X' button: createButton("X", 30 + 20, bottomUIY + 55, () => {}, buttonTextStyle, uiContainer, btnW, btnH).alpha = 0.3;

        // Add all created buttons from ButtonFactory to the uiContainer
        // (ButtonFactory now returns the button, it doesn't add it)
        // We need a way to get references to buttons created by createButton if UIManager needs them.
        // Option 1: createButton adds to uiContainer (simpler now)
        // Option 2: Game collects buttons and passes to UIManager (more complex)
        // Let's modify ButtonFactory to add to uiContainer for now.
        // --> Requires reading/modifying ButtonFactory.js again. Let's do that *after* this file.

    }

    update(ticker) {
        const delta = ticker.deltaTime;
        const now = ticker.lastTime;
        let anyReelMoving = false;

        try {
            // Update all reels
            reels.forEach(reel => {
                const isActive = reel.update(delta, now);
                if (isActive) {
                    anyReelMoving = true;
                }
            });

            // Update particle animations
            updateParticles(delta);

            // Check if the spin has just ended
            if (state.isSpinning && !anyReelMoving) {
                this.handleSpinEnd();
            }

        } catch (err) {
            console.error("Error in game loop:", err);
            // Ensure app and ticker exist before stopping
            if (app?.ticker) {
                app.ticker.stop(); // Stop the loop on critical error
            }
            alert("Game loop critical error. Check console.");
        }
    }

    handleSpinEnd() {
        updateState({ isSpinning: false, isTransitioning: true }); // Mark as transitioning
        console.log("All reels stopped moving (final check).");

        // Short delay before evaluating wins to allow final animations/settling
        setTimeout(() => {
            console.log("Evaluating wins...");
            evaluateWin(); // Evaluate wins (updates state.lastTotalWin, etc.)

            updateState({ isTransitioning: false }); // End transition after evaluation

            // Check game state to decide next action
            if (state.isInFreeSpins) {
                // handleFreeSpinEnd will decide if another FS starts or exits
                // handleFreeSpinEnd(); // This is called within evaluateWin if FS trigger happens? No, called after eval.
                // --> Need to import and call handleFreeSpinEnd from FreeSpins.js
                // --> Let's assume evaluateWin handles the FS trigger, and we call handleFreeSpinEnd *after* eval if in FS.
                 import('../features/FreeSpins.js').then(fs => fs.handleFreeSpinEnd()); // Dynamic import to avoid circular dependency? Or pass function ref.
            } else if (state.isAutoplaying) {
                handleAutoplayNextSpin(); // Check if next autoplay spin should start
            } else {
                setButtonsEnabled(true); // Re-enable buttons for manual play
            }
        }, 50 * winAnimDelayMultiplier); // Use animation multiplier for delay
    }
}

// --- Global Functions used by other modules ---

/**
 * Starts the spinning process for all reels.
 * Called by ButtonHandlers.startSpin.
 */
export function startSpinLoop(isTurbo) {
    // Clear previous win lines before starting spin
    clearWinLines();

    // Get current time to calculate absolute stop times
    // Note: app.ticker.lastTime might be more accurate if available globally or passed in
    const startTime = performance.now();

    // Start all reels spinning and schedule their stops
    reels.forEach((reel, i) => {
        reel.startSpinning(isTurbo); // Start spinning visually

        // Calculate the absolute time this reel should come to a complete stop
        // Select duration and stagger based on turbo state
        const currentBaseDuration = state.isTurboMode ? turboBaseSpinDuration : baseSpinDuration;
        const currentStagger = state.isTurboMode ? turboReelStopStagger : REEL_STOP_STAGGER;

        const targetStopTime = startTime + currentBaseDuration + i * currentStagger;

        // Tell the reel when to stop and which index to target
        // (stopIndex is determined internally by the reel in startSpinning for now)
        reel.scheduleStop(targetStopTime);
        console.log(`Game: Reel ${i} scheduled to stop at ${targetStopTime.toFixed(0)}ms`);
    });

    // No need for targetStoppingReelIndex or setTimeout for initiation
    updateState({ targetStoppingReelIndex: -1 });
}

// Removed triggerNextReelStop function as it's no longer needed
// Removed old initiateStop logic using setTimeout
</file_content>

<file_content path="./src//core/Symbol.js">
import * as PIXI from 'pixi.js';
import { SYMBOL_DEFINITIONS } from '../config/symbolDefinitions.js';
import { SYMBOL_SIZE, REEL_WIDTH } from '../config/gameSettings.js';

/**
 * Creates a PixiJS graphic representation for a given symbol ID.
 * @param {string} symbolId - The ID of the symbol (e.g., "FACE1", "SCAT").
 * @returns {Symbol} An instance of the Symbol class.
 */
export function createSymbolGraphic(symbolId) {
  return new Symbol(symbolId);
}

/**
 * Represents a single symbol graphic on the reel.
 * Extends PIXI.Container to hold graphics and custom properties.
 */
export class Symbol extends PIXI.Container { // Added export
  symbolId; // The ID of the symbol ('FACE1', 'SCAT', etc.)
  isAnimating = false; // Flag for win animations

  constructor(symbolId) {
    super(); // Call PIXI.Container constructor
    this.symbolId = symbolId;
  const definition = SYMBOL_DEFINITIONS.find(
    (s) => s.id === symbolId
  );

  // Fallback for missing definition
  if (!definition) {
    console.warn("Symbol definition not found:", symbolId);
    const fb = new PIXI.Graphics()
      .rect(0, 0, SYMBOL_SIZE * 0.9, SYMBOL_SIZE * 0.9)
      .fill(0xff0000);
    const txt = new PIXI.Text({ text: "ERR", style: { fill: 0xffffff } });
    txt.anchor.set(0.5);
    txt.x = SYMBOL_SIZE * 0.45;
    txt.y = SYMBOL_SIZE * 0.45;
    fb.addChild(txt);
    // Add the error graphic to this Symbol instance instead of returning
    this.addChild(fb);
    // No explicit return needed from constructor, but we stop further graphic creation
    return;
  }

  // Use 'this' instead of 'container' as we are inside the class constructor
  // this.symbolId = symbolId; // Already set above

  const graphicWidth = SYMBOL_SIZE * 0.9;
  const graphicHeight = SYMBOL_SIZE * 0.9;
  const fillColor = definition.color;

  // Background
  const background = new PIXI.Graphics()
    .roundRect(0, 0, graphicWidth, graphicHeight, 15)
    .fill({ color: fillColor, alpha: 0.85 });

  // Border
  const border = new PIXI.Graphics()
    .roundRect(0, 0, graphicWidth, graphicHeight, 15)
    .stroke({ width: 3, color: 0xffffff, alpha: 0.4, alignment: 0.5 });

  // Text
  const symbolText = new PIXI.Text({
    text: definition.text,
    style: {
      fontFamily: '"Arial Black", Gadget, sans-serif',
      fontSize: SYMBOL_SIZE * 0.6,
      fill: 0xffffff,
      align: "center",
      stroke: { color: 0x000000, width: 5, join: "round" },
      dropShadow: {
        color: "#000000",
        angle: Math.PI / 4,
        distance: 3,
        blur: 3,
        alpha: 0.7,
      },
    },
  });
  symbolText.anchor.set(0.5);
  symbolText.x = graphicWidth / 2;
  symbolText.y = graphicHeight / 2;

  this.addChild(background, border, symbolText);

  // Set pivot to center for easier rotation/scaling if needed later
  this.pivot.set(graphicWidth / 2, graphicHeight / 2);
  // Position in the center of the reel width
  this.x = REEL_WIDTH / 2;

  // No return needed from constructor
 }
}
</file_content>

<file_content path="./src//core/GameState.js">
import { AUTOPLAY_SPINS_DEFAULT, BET_PER_LINE_LEVELS, NUM_REELS } from '../config/gameSettings.js'; // Import NUM_REELS
import { NUM_PAYLINES } from '../config/paylines.js'; // Corrected import

// --- Central Game State ---
// Using 'let' for properties that change, 'const' for initial settings if not modified elsewhere.
export let state = {
    // Core gameplay
    balance: 10000,
    currentBetPerLine: BET_PER_LINE_LEVELS[3] || 0.1, // Default to a mid-level bet
    currentTotalBet: (BET_PER_LINE_LEVELS[3] || 0.1) * NUM_PAYLINES,
    numReels: NUM_REELS, // Add number of reels to state
    lastTotalWin: 0,
    /** @type {Array<{lineIndex: number, symbolId: string, count: number, winAmount: number, symbols: Array<import('./Symbol.js').Symbol>}>} */
    winningLinesInfo: [], // Array of { lineIndex, symbolId, count, winAmount, symbols }

    // Spin state
    isSpinning: false,      // Master flag: Are reels currently spinning/stopping?
    isTransitioning: false, // Is the game in a non-interactive transition (e.g., FS entry/exit message)?
    targetStoppingReelIndex: -1, // Which reel index is expected to stop next (for chained stops)

    // Features state
    isAutoplaying: false,
    autoplaySpinsRemaining: 0,
    autoplaySpinsDefault: AUTOPLAY_SPINS_DEFAULT, // Store the default value
    isTurboMode: false,
    isInFreeSpins: false,
    freeSpinsRemaining: 0,
    totalFreeSpinsWin: 0,

    // References (can be set during initialization if needed, though maybe better managed in Game.js)
    // reels: [], // Maybe keep reel references in Game.js instead?
    // uiElements: {}, // Maybe keep UI references in UIManager.js?
};

/**
 * Initializes the game state to default values.
 * Can be called at the start or to reset the game.
 */
export function initGameState() {
    state = {
        ...state, // Keep potential references if any were added dynamically
        balance: 10000,
        currentBetPerLine: BET_PER_LINE_LEVELS[3] || 0.1,
        currentTotalBet: (BET_PER_LINE_LEVELS[3] || 0.1) * NUM_PAYLINES,
        numReels: NUM_REELS, // Add number of reels to state reset
        lastTotalWin: 0,
        winningLinesInfo: [], // Reset to empty array
        isSpinning: false,
        isTransitioning: false,
        targetStoppingReelIndex: -1,
        isAutoplaying: false,
        autoplaySpinsRemaining: 0,
        isTurboMode: false, // Reset turbo on init? Or keep user preference? Let's reset for now.
        isInFreeSpins: false,
        freeSpinsRemaining: 0,
        totalFreeSpinsWin: 0,
    };
    console.log("GameState Initialized:", state);
}

/**
 * Updates the central game state object with new values.
 * Merges the provided updates with the existing state.
 * @param {Partial<state>} updates - An object containing state properties to update.
 */
export function updateState(updates) {
    // Basic merge, could add validation or logging later
    state = { ...state, ...updates };
    // console.log("GameState Updated:", updates, "New State:", state); // Optional: Log updates
}

// Optional: Add getter functions if direct state access is discouraged later
// export function getBalance() { return state.balance; }
// export function isSpinning() { return state.isSpinning; }
// ... etc.
</file_content>

<file_content path="./src//config/gameSettings.js">
export const GAME_WIDTH = 1000;
export const GAME_HEIGHT = 700;
export const NUM_REELS = 5;
export const SYMBOLS_PER_REEL_VISIBLE = 4;
export const REEL_WIDTH = 150;
export const SYMBOL_SIZE = 130;
export const SCATTER_SYMBOL_ID = "SCAT";
export const MIN_SCATTERS_FOR_FREE_SPINS = 3;
export const FREE_SPINS_AWARDED = 10;
export const AUTOPLAY_SPINS_DEFAULT = 10;
export const BET_PER_LINE_LEVELS = [0.01, 0.02, 0.05, 0.1, 0.2, 0.5, 1.0, 2.0];
export const ENABLE_FREE_SPINS = false; // Config flag to enable/disable free spins feature
export const normalBgColor = 0x2f4f4f;
export const freeSpinsBgColor = 0x4b0082;

// Derived constants (can also be calculated where needed, but useful here)
export const REEL_VISIBLE_HEIGHT = SYMBOLS_PER_REEL_VISIBLE * SYMBOL_SIZE;
export const reelAreaX = (GAME_WIDTH - NUM_REELS * REEL_WIDTH) / 2;
export const reelAreaY = 80; // Adjust as needed
export const bottomUIY = GAME_HEIGHT - 100; // Adjust as needed
</file_content>

<file_content path="./src//config/paylines.js">
export const PAYLINES = [
  [1, 1, 1, 1, 1], // Line 1 (Middle row)
  [0, 0, 0, 0, 0], // Line 2 (Top row)
  [2, 2, 2, 2, 2], // Line 3 (Row below middle)
  [3, 3, 3, 3, 3], // Line 4 (Bottom row)
  [0, 1, 2, 1, 0], // Line 5 (V shape)
  [3, 2, 1, 2, 3], // Line 6 (Inverted V)
  [0, 1, 1, 1, 0], // Line 7
  [3, 2, 2, 2, 3], // Line 8
  [1, 2, 1, 0, 1], // Line 9
  [2, 1, 2, 3, 2], // Line 10
  [0, 0, 1, 2, 2], // Line 11
  [3, 3, 2, 1, 1], // Line 12
  [1, 0, 1, 2, 3], // Line 13
  [2, 3, 2, 1, 0], // Line 14
  [1, 2, 3, 2, 1], // Line 15
];

// Derived constant
export const NUM_PAYLINES = PAYLINES.length;
</file_content>

<file_content path="./src//config/symbolDefinitions.js">
export const SYMBOL_DEFINITIONS = [
  {
    id: "FACE1",
    color: 0xffd700,
    text: "(:",
    payout: { 3: 10, 4: 25, 5: 100 },
  },
  {
    id: "FACE2",
    color: 0x8b4513,
    text: "{:",
    payout: { 3: 8, 4: 20, 5: 80 },
  },
  {
    id: "FACE3",
    color: 0xde6fa1,
    text: "):",
    payout: { 3: 6, 4: 15, 5: 60 },
  },
  {
    id: "KNIFE",
    color: 0xa9a9a9,
    text: "K",
    payout: { 3: 4, 4: 10, 5: 40 },
  },
  {
    id: "CUP",
    color: 0xdc143c,
    text: "U",
    payout: { 3: 3, 4: 8, 5: 30 },
  },
  {
    id: "PATCH",
    color: 0x4682b4,
    text: "!",
    payout: { 3: 2, 4: 5, 5: 20 },
  },
  {
    id: "SCAT",
    color: 0xff00ff,
    text: "$",
    payout: { 3: 5, 4: 10, 5: 25 }, // Note: Scatter payout is often handled differently (any position)
  },
  {
    id: "LOW",
    color: 0x556b2f,
    text: "~",
    payout: { 3: 1, 4: 2, 5: 10 },
  },
];

// Derived Paytable for quick lookup
export const PAYTABLE = SYMBOL_DEFINITIONS.reduce((table, sym) => {
  if (sym.payout) table[sym.id] = sym.payout;
  return table;
}, {});
</file_content>

<file_content path="./src//config/animationSettings.js">
// Base settings (can be modified by Turbo Mode)
export let spinAcceleration = 0.1; // Increased from 0.05
export let maxSpinSpeed = 1.4; // Increased from 1.0
export let spinDeceleration = 0.92; // Increased deceleration for faster stop
export let minSpinSpeedBeforeSnap = 0.05;
export let stopDelayBase = 300; // Reduced initial delay
export let winAnimDelayMultiplier = 1.0;
export const REEL_STOP_STAGGER = 150; // Slower stagger for normal mode

// New settings for fixed duration + tween stop
export let baseSpinDuration = 1500; // Slower base duration for normal mode
export let stopTweenDuration = 250; // ms duration of the final tween into stop position

// Turbo settings modifiers (applied directly where needed)
export const turboSpinAcceleration = 0.15;
export const turboMaxSpinSpeed = 1.8;
// export const turboSpinDeceleration = 0.96; // No longer used by tween logic
// export const turboMinSpinSpeedBeforeSnap = 0.2; // No longer used by tween logic
// export const turboStopDelayBase = 100; // No longer used by tween logic
export const turboWinAnimDelayMultiplier = 0.2;
export const turboBaseSpinDuration = 500; // Faster duration for turbo
export const turboReelStopStagger = 50;   // Tighter stagger for turbo

// Bounce animation (Keep for reference, but skipBounce is unused now)
export const OVERSHOOT_AMOUNT = 0.15;
export const OVERSHOOT_DURATION = 120; // ms
export const BOUNCE_BACK_DURATION = 180; // ms
export let skipBounceInTurbo = true; // Configurable turbo behavior (Currently unused by tween logic)

// Removed updateAnimationSettings function - settings are applied directly based on state.isTurboMode
</file_content>

<file_content path="./src//config/reelStrips.js">
export const REEL_STRIPS = [
  [
    "FACE1",
    "KNIFE",
    "FACE2",
    "LOW",
    "CUP",
    "PATCH",
    "LOW", // Replace SCAT with LOW
    "FACE3",
    "LOW",
    "KNIFE",
    "PATCH",
    "FACE1",
    "LOW",
    "CUP",
    "FACE2",
    "SCAT",
  ],
  [
    "FACE2",
    "PATCH",
    "FACE3",
    "LOW",
    "KNIFE",
    "CUP",
    "FACE1",
    "LOW", // Replace SCAT with LOW
    "LOW",
    "FACE2",
    "PATCH",
    "KNIFE",
    "LOW",
    "FACE3",
    "CUP",
    "SCAT",
  ],
  [
    "FACE3",
    "CUP",
    "KNIFE",
    "LOW", // Replace SCAT with LOW
    "FACE1",
    "PATCH",
    "LOW",
    "FACE2",
    "KNIFE",
    "FACE3", // Corrected
    "LOW",   // Corrected
    "PATCH",
    "SCAT",
    "CUP",
    "FACE1",
    "LOW",
  ],
  [
    "FACE1",
    "LOW",
    "PATCH",
    "CUP",
    "FACE2",
    "KNIFE",
    "LOW", // Corrected
    "FACE3",
    "PATCH",
    "LOW",
    "FACE1",
    "CUP",
    "KNIFE",
    "FACE2",
    "LOW",
    "SCAT",
  ],
  [
    "SCAT",
    "FACE2",
    "LOW",
    "KNIFE",
    "FACE3",
    "CUP",
    "PATCH",
    "FACE1",
    "LOW",
    "KNIFE",
    "FACE2",
    "PATCH",
    "FACE3",
    "LOW",
    "CUP",
    "FACE1",
  ],
];
</file_content>

<file_content path="./src//features/FreeSpins.js">
import { FREE_SPINS_AWARDED, freeSpinsBgColor, normalBgColor } from '../config/gameSettings.js';
import { winAnimDelayMultiplier } from '../config/animationSettings.js';
import { state, updateState } from '../core/GameState.js'; // Assuming state management
import { showOverlayMessage } from '../ui/Notifications.js'; // Assuming notification handling
import { setButtonsEnabled, updateAutoplayButtonState } from '../ui/UIManager.js'; // Assuming UI management
import { startSpin } from '../ui/ButtonHandlers.js'; // Assuming spin initiation

// Reference to the Pixi app (needed for background color change)
let appRef = null;
export function initFreeSpins(app) {
    appRef = app;
}

/**
 * Enters the Free Spins mode.
 * Updates state, shows message, changes background, and starts the first free spin.
 */
export function enterFreeSpins() {
    if (state.isInFreeSpins || !appRef) return; // Prevent re-entry or if not initialized

    console.log(`Enter Free Spins: ${FREE_SPINS_AWARDED}`);
    updateState({
        isInFreeSpins: true,
        freeSpinsRemaining: FREE_SPINS_AWARDED,
        totalFreeSpinsWin: 0, // Reset total win for the feature
    });

    // Stop autoplay if it was running
    if (state.isAutoplaying) {
        updateState({ isAutoplaying: false, autoplaySpinsRemaining: 0 });
        updateAutoplayButtonState(); // Update UI
        console.log("Autoplay stopped for FS.");
    }

    // Change background color
    appRef.renderer.background.color = freeSpinsBgColor;

    // updateInfoOverlay(); // Handled by UIManager based on state change
    setButtonsEnabled(false); // Disable controls during transition
    updateState({ isTransitioning: true });

    // Show entry message
    showOverlayMessage(
        `${FREE_SPINS_AWARDED}\nFREE SPINS`,
        2000, // Use base duration, showOverlayMessage applies multiplier
        () => {
            updateState({ isTransitioning: false });
            setButtonsEnabled(false); // Keep buttons disabled during FS (except maybe stop?)
            startFreeSpin(); // Start the first spin after the message
        }
    );
}

/**
 * Initiates a single free spin if conditions are met.
 */
function startFreeSpin() {
    if (!state.isInFreeSpins || state.freeSpinsRemaining <= 0 || state.isSpinning || state.isTransitioning) {
        console.log("Cannot start free spin:", {fs: state.isInFreeSpins, rem: state.freeSpinsRemaining, spin: state.isSpinning, trans: state.isTransitioning});
        return;
    }
    // updateInfoOverlay(); // Handled by UIManager
    setButtonsEnabled(false); // Ensure buttons remain disabled
    startSpin(true); // Call the main startSpin function, flagging it as a free spin
}

/**
 * Exits the Free Spins mode.
 * Shows summary message, resets state, changes background back.
 */
export function exitFreeSpins() {
    if (!state.isInFreeSpins || !appRef) return;

    console.log(`Exit Free Spins. Total Win: €${state.totalFreeSpinsWin.toFixed(2)}`);
    updateState({ isTransitioning: true }); // Prevent actions during transition

    // Show summary message
    showOverlayMessage(
        `FREE SPINS COMPLETE\nTOTAL WIN:\n€${state.totalFreeSpinsWin.toFixed(2)}`,
        3000, // Use base duration
        () => {
            // Reset state AFTER the message
            updateState({
                isInFreeSpins: false,
                freeSpinsRemaining: 0,
                isTransitioning: false,
                // Keep totalFreeSpinsWin for display until next regular win? Or reset here?
                // totalFreeSpinsWin: 0, // Let's reset it here for clarity
            });
            appRef.renderer.background.color = normalBgColor; // Change background back
            // updateInfoOverlay(); // Handled by UIManager
            setButtonsEnabled(true); // Re-enable controls
            // updateDisplays(); // Ensure final win amount is shown correctly if needed
        }
    );
}

/**
 * Handles the logic after a free spin completes.
 * Updates total win, decrements remaining spins, and decides whether to start next spin or exit.
 */
export function handleFreeSpinEnd() {
    if (!state.isInFreeSpins) return;

    // Add the win from the completed spin to the total FS win
    updateState({ totalFreeSpinsWin: state.totalFreeSpinsWin + state.lastTotalWin });
    updateState({ freeSpinsRemaining: state.freeSpinsRemaining - 1 });

    // updateInfoOverlay(); // Handled by UIManager

    // Delay before next action (next spin or exit)
    const delay = (state.isTurboMode ? 200 : 800) * winAnimDelayMultiplier;
    updateState({ isTransitioning: true });

    setTimeout(() => {
        updateState({ isTransitioning: false });
        if (state.freeSpinsRemaining > 0) {
            startFreeSpin(); // Start the next free spin
        } else {
            exitFreeSpins(); // No spins left, exit the mode
        }
    }, delay);
}
</file_content>

<file_content path="./src//features/TurboMode.js">
import { skipBounceInTurbo } from '../config/animationSettings.js'; // Removed updateAnimationSettings import
import { state } from '../core/GameState.js'; // Assuming state access
import { updateTurboButtonState as updateBtnState } from '../ui/UIManager.js'; // Assuming UI management

// Placeholder for reels data - this should be passed in or accessed via GameState/Game module
let reelsRef = [];
export function initTurboMode(reels) {
    reelsRef = reels;
}

/**
 * Applies turbo settings to the game.
 * Updates animation timings and reel bounce behavior based on the turbo state.
 * @param {boolean} isTurbo - Whether turbo mode is currently active.
 */
export function applyTurboSettings(isTurbo) {
    // updateAnimationSettings is removed as settings are now applied directly based on state.isTurboMode

    // Update reel-specific behavior if needed (like skipping bounce, though currently unused by tween logic)
    // This assumes reelsRef is initialized and contains reel objects with a 'skipBounce' property
    if (reelsRef && reelsRef.length > 0) {
        reelsRef.forEach(reel => {
            if (reel) { // Check if reel object exists
                reel.skipBounce = isTurbo && skipBounceInTurbo;
            } else {
                console.warn("TurboMode: Found undefined reel in reelsRef during applyTurboSettings.");
            }
        });
    } else {
        // This might happen if called before reels are created, maybe log a warning
        // console.warn("TurboMode: applyTurboSettings called before reelsRef was initialized or populated.");
    }

    // Update the button state visually (handled by UIManager)
    // updateBtnState(isTurbo); // Call the function imported from UIManager
}

// Note: updateTurboButtonState is now assumed to be part of UIManager.js
// It will read the `isTurboMode` from the shared state and update the button's appearance.
// The toggleTurbo function in ButtonHandlers.js calls applyTurboSettings here
// and then calls the UIManager's updateTurboButtonState.
</file_content>

<file_content path="./src//features/WinEvaluation.js">
import { PAYLINES, NUM_PAYLINES } from '../config/paylines.js';
import { PAYTABLE } from '../config/symbolDefinitions.js';
import {
    SCATTER_SYMBOL_ID, MIN_SCATTERS_FOR_FREE_SPINS, SYMBOLS_PER_REEL_VISIBLE,
    ENABLE_FREE_SPINS // Ensure this is imported
} from '../config/gameSettings.js';
import { state, updateState } from '../core/GameState.js'; // Assuming state management
import { drawWinLines } from './PaylineGraphics.js'; // Assuming graphics handling
import { playWinAnimations, animateWinningSymbols } from './Animations.js'; // Assuming animation handling
import { enterFreeSpins } from './FreeSpins.js'; // Assuming FreeSpins handling
import { updateDisplays } from '../ui/UIManager.js'; // Assuming UI update handling
// import { flashElement } from '../ui/Notifications.js'; // Assuming notification handling

// Placeholder for reels data - this should be passed in or accessed via GameState/Game module
let reelsRef = [];
export function initWinEvaluation(reels) {
    reelsRef = reels;
}

/**
 * Evaluates the win based on the current stopped reels.
 * Calculates line wins and scatter triggers.
 * Updates game state and triggers win animations/sounds.
 */
export function evaluateWin() {
    let calculatedTotalWin = 0;
    let calculatedWinningLines = []; // Initialize as empty array
    const resultsGrid = getResultsGrid();
    console.log("WinEvaluation - Results Grid:", JSON.stringify(resultsGrid)); // DEBUG: Log the grid
    let scatterCount = 0;

    // --- Calculate Line Wins ---
    PAYLINES.forEach((linePath, lineIndex) => {
        // console.log(`--- Checking Line ${lineIndex} --- Path: ${linePath}`); // DEBUG: Line Start
        let lineSymbolIds = [];
        let lineSymbolObjects = []; // Store references to the actual symbol objects on screen

        for (let reelIndex = 0; reelIndex < state.numReels; reelIndex++) { // Use state.numReels
            const rowIndex = linePath[reelIndex];
            if (rowIndex >= 0 && rowIndex < SYMBOLS_PER_REEL_VISIBLE) {
                const symbolId = resultsGrid[reelIndex][rowIndex];
                lineSymbolIds.push(symbolId);

                // Find the corresponding symbol object on the reel
                // Assumes symbols array index corresponds to visual row + 1 (for buffer symbol)
                const symbolObj = reelsRef[reelIndex]?.symbols[rowIndex + 1];
                if (symbolObj && symbolObj.symbolId === symbolId) {
                    lineSymbolObjects.push(symbolObj);
                } else {
                    // This case might happen if grid/reels are out of sync, log warning?
                    lineSymbolObjects.push(null);
                }
            } else {
                // Should not happen with valid PAYLINES definition
                lineSymbolIds.push(null);
                lineSymbolObjects.push(null);
            }
        }
        // console.log(`Line ${lineIndex} Symbols: ${lineSymbolIds}`); // DEBUG: Symbols on line

        const firstSymbolId = lineSymbolIds[0];
        // console.log(`Line ${lineIndex} First Symbol: ${firstSymbolId}`); // DEBUG: First symbol
        if (!firstSymbolId || !PAYTABLE[firstSymbolId]) {
            // console.log(`Line ${lineIndex}: Skipping - First symbol invalid or not payable.`); // DEBUG
            return; // Skip if first symbol isn't payable
        }

        let matchCount = 1;
        for (let i = 1; i < state.numReels; i++) {
            if (lineSymbolIds[i] === firstSymbolId) {
                matchCount++;
            } else {
                break; // Symbols must match consecutively from the left
            }
        }
        // console.log(`Line ${lineIndex} Match Count: ${matchCount}`); // DEBUG: Match count

        const payoutInfo = PAYTABLE[firstSymbolId];
        const expectedPayout = payoutInfo ? payoutInfo[matchCount] : undefined;
        // console.log(`Line ${lineIndex} Payout Info: ${JSON.stringify(payoutInfo)}, Expected Payout for ${matchCount}: ${expectedPayout}`); // DEBUG: Payout check

        if (matchCount >= 3 && payoutInfo && expectedPayout !== undefined) { // Check expectedPayout specifically
            const lineWin = expectedPayout * state.currentBetPerLine;
            calculatedTotalWin += lineWin;
            const winInfo = {
                lineIndex: lineIndex,
                symbolId: firstSymbolId,
                count: matchCount,
                winAmount: lineWin,
                symbols: lineSymbolObjects.slice(0, matchCount).filter(s => s !== null), // Store refs to winning symbols
            };
            calculatedWinningLines.push(winInfo);
            console.log("WinEvaluation - WIN FOUND:", winInfo); // DEBUG: Log found win
        }
    });

    // --- Check for Scatters ---
    resultsGrid.forEach(col => col.forEach(symId => {
        if (symId === SCATTER_SYMBOL_ID) {
            scatterCount++;
        }
    }));

    // --- Update State and Trigger Effects ---
    updateState({ lastTotalWin: calculatedTotalWin, winningLinesInfo: calculatedWinningLines });

    if (calculatedTotalWin > 0) {
        if (!state.isInFreeSpins) {
            updateState({ balance: state.balance + calculatedTotalWin });
        }
        console.log(`Win: €${calculatedTotalWin.toFixed(2)}`);
        updateDisplays(); // Update balance/win text
        // flashElement(winText, 0xffff00, 200, 3); // Needs UIManager reference to winText
        drawWinLines(calculatedWinningLines); // Pass winning lines info
        playWinAnimations(calculatedTotalWin, state.currentTotalBet); // Pass win and bet for threshold checks
        calculatedWinningLines.forEach(info => {
            if (info.symbols.length > 0) {
                animateWinningSymbols(info.symbols);
            }
        });
    } else {
        console.log("No line win.");
        updateDisplays(); // Ensure win display is cleared if needed
    }

    // --- Trigger Free Spins (if applicable and enabled) ---
    if (ENABLE_FREE_SPINS && !state.isInFreeSpins && scatterCount >= MIN_SCATTERS_FOR_FREE_SPINS) {
        console.log(`WinEvaluation: ${scatterCount} scatters found. Triggering free spins (Enabled: ${ENABLE_FREE_SPINS}).`); // DEBUG
        // Delay slightly after win animations if any
        const delay = (calculatedTotalWin > 0 ? 1000 : 100) * state.winAnimDelayMultiplier;
        updateState({ isTransitioning: true }); // Prevent actions during transition
        setTimeout(() => enterFreeSpins(), delay);
    }
}

/**
 * Gets the grid of symbol IDs currently visible on the reels.
 * @returns {string[][]} A 2D array representing the visible grid [reelIndex][rowIndex].
 */
function getResultsGrid() {
    const grid = [];
    reelsRef.forEach((reel) => {
        const column = [];
        // Calculate visible symbols based on stopIndex
        for (let rowIndex = 0; rowIndex < SYMBOLS_PER_REEL_VISIBLE; rowIndex++) {
            const symbolIndexOnStrip = (reel.stopIndex + rowIndex + reel.strip.length) % reel.strip.length;
            column.push(reel.strip[symbolIndexOnStrip]);
        }
        grid.push(column);
    });
    // console.log("Result Grid:", grid); // Optional: Debugging
    return grid;
}
</file_content>

<file_content path="./src//features/Animations.js">
import * as PIXI from 'pixi.js';
import { winAnimDelayMultiplier } from '../config/animationSettings.js';
import { GAME_WIDTH, GAME_HEIGHT } from '../config/gameSettings.js';

// References to containers (need initialization)
let overlayContainer = null;
let particleContainer = null;
let winOverlayAnimInterval = null; // Interval ID for big win text animation
const particles = []; // Array to hold active particle objects

/**
 * Initializes references to necessary PIXI containers.
 * @param {PIXI.Container} overlayCont - Container for big win text overlays.
 * @param {PIXI.Container} particleCont - Container for particle effects.
 */
export function initAnimations(overlayCont, particleCont) {
    if (!overlayCont || !particleCont) {
        console.error("Animations: Provided containers are invalid.");
        return;
    }
    overlayContainer = overlayCont;
    particleContainer = particleCont;
    console.log("Animations initialized with containers.");
}

/**
 * Animates the scale of winning symbols with a bounce effect.
 * @param {Array<import('../core/Symbol.js').Symbol>} symbolsToAnimate - Array of Symbol instances to animate.
 */
export function animateWinningSymbols(symbolsToAnimate) {
    if (!symbolsToAnimate) return;

    symbolsToAnimate.forEach((symbol) => {
        // Check if symbol is valid and not already animating
        if (symbol?.scale && !symbol.isAnimating) {
            symbol.isAnimating = true; // Mark as animating
            const originalScale = 1.0;
            symbol.scale.set(originalScale); // Ensure starting scale

            const targetScaleUp = originalScale * 1.15;
            const baseDuration = 150; // ms per half-bounce
            const duration = baseDuration * winAnimDelayMultiplier; // Adjust for turbo
            const bounces = 2; // Number of up/down cycles
            let count = 0;
            let animTimeout = null;

            function bounceSymbol() {
                // Stop if symbol is destroyed or removed
                if (!symbol?.scale || !symbol.parent) {
                    if (symbol) symbol.isAnimating = false; // Reset flag if possible
                    clearTimeout(animTimeout);
                    return;
                }

                // End animation after specified bounces
                if (count >= bounces * 2) {
                    symbol.scale.set(originalScale); // Reset to original scale
                    symbol.isAnimating = false; // Unmark
                    return;
                }

                // Alternate target scale
                const target = count % 2 === 0 ? targetScaleUp : originalScale;
                symbol.scale.set(target); // Apply scale change
                count++;

                // Schedule next step
                animTimeout = setTimeout(bounceSymbol, duration);
            }

            bounceSymbol(); // Start the animation loop
        }
    });
}

/**
 * Plays big/mega win text animations and triggers particle effects.
 * @param {number} winAmount - The total amount won in the spin.
 * @param {number} currentTotalBet - The total bet amount for the spin (for threshold calculation).
 */
export function playWinAnimations(winAmount, currentTotalBet) {
    if (!overlayContainer) {
        console.error("Animations: Overlay container not initialized for win animations.");
        return;
    }
    // Clear previous animation interval if any
    if (winOverlayAnimInterval) clearInterval(winOverlayAnimInterval);
    overlayContainer.removeChildren(); // Clear previous win text

    // Define win thresholds
    const bigWinThreshold = currentTotalBet * 10;
    const megaWinThreshold = currentTotalBet * 25;
    let winTextStr = "";

    // Determine win level text
    if (winAmount >= megaWinThreshold) winTextStr = "MEGA WIN!";
    else if (winAmount >= bigWinThreshold) winTextStr = "BIG WIN!";

    // --- Big/Mega Win Text Animation ---
    if (winTextStr) {
        const winOverlayText = new PIXI.Text({
            text: winTextStr + `\n€${winAmount.toFixed(2)}`,
            style: {
                fontFamily: "Impact, Charcoal, sans-serif",
                fontSize: 70,
                fill: [0xffff00, 0xffaa00], // Use hex numbers
                stroke: { color: "#8B0000", width: 5 },
                dropShadow: { color: "#000", distance: 5, blur: 5, alpha: 0.8 },
                align: 'center', // Use string literal
                // lineSpacing: 10, // Removed invalid property
            },
        });
        winOverlayText.anchor.set(0.5);
        winOverlayText.x = GAME_WIDTH / 2;
        winOverlayText.y = GAME_HEIGHT / 2 - 50; // Position slightly above center
        winOverlayText.scale.set(0.1); // Start small
        overlayContainer.addChild(winOverlayText);

        let scale = 0.1;
        let alpha = 1.0;
        let phase = 0; // 0: scaling up, 1: holding, 2: fading out
        let holdCounter = 0;
        const holdDuration = 50; // Frames/intervals to hold at full size
        const animSpeed = 20; // Interval speed (ms)

        winOverlayAnimInterval = setInterval(() => {
            if (!winOverlayText?.parent) { // Stop if text is removed
                clearInterval(winOverlayAnimInterval);
                return;
            }

            const currentAnimSpeed = animSpeed * winAnimDelayMultiplier; // Adjust speed for turbo

            if (phase === 0) { // Scaling up
                scale += 0.05 * (currentAnimSpeed / 20); // Adjust scale increment based on speed
                winOverlayText.scale.set(Math.min(1.0, scale));
                if (scale >= 1.0) {
                    phase = 1; // Move to hold phase
                    holdCounter = 0;
                }
            } else if (phase === 1) { // Holding
                holdCounter++;
                if (holdCounter * currentAnimSpeed >= holdDuration * 20) { // Adjust hold duration based on speed
                    phase = 2; // Move to fade out phase
                }
            } else if (phase === 2) { // Fading out
                alpha -= 0.04 * (currentAnimSpeed / 20); // Adjust alpha decrement
                winOverlayText.alpha = Math.max(0, alpha);
                if (alpha <= 0) {
                    clearInterval(winOverlayAnimInterval); // Stop animation
                    if (winOverlayText.parent) overlayContainer.removeChild(winOverlayText);
                    winOverlayText.destroy(); // Clean up
                }
            }
        }, animSpeed); // Base interval remains 20ms, logic adjusts based on multiplier
    }

    // --- Particle Effect ---
    // Trigger particles based on win amount relative to bet
    const numParticles = Math.min(60, Math.floor((winAmount / currentTotalBet) * 3));
    if (numParticles > 0) {
        createParticles(numParticles);
    }
}

/**
 * Creates a specified number of particle objects.
 * @param {number} count - The number of particles to create.
 */
function createParticles(count) {
    if (!particleContainer) {
        console.error("Animations: Particle container not initialized.");
        return;
    }
    for (let i = 0; i < count; i++) {
        const p = {
            gfx: new PIXI.Graphics()
                .circle(0, 0, Math.random() * 5 + 3) // Random size
                .fill({ color: Math.random() > 0.5 ? 0xffd700 : 0xf1c40f }), // Random gold/yellow
            vx: (Math.random() - 0.5) * 8, // Horizontal velocity
            vy: -Math.random() * 10 - 8, // Initial upward velocity
            gravity: 0.35,
            life: Math.random() * 80 + 40, // Lifetime in frames/updates
            alpha: 1.0,
        };
        p.fade = 1 / p.life; // Alpha fade per update
        // Start position around center
        p.gfx.x = GAME_WIDTH / 2 + (Math.random() - 0.5) * 100;
        p.gfx.y = GAME_HEIGHT / 2 + 50;
        particles.push(p);
        particleContainer.addChild(p.gfx);
    }
}

/**
 * Updates the position and state of all active particles.
 * Should be called in the main game loop.
 * @param {number} delta - Time delta since the last frame (usually from ticker).
 */
export function updateParticles(delta) {
    if (!particleContainer) return; // Don't run if not initialized

    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];

        // Apply physics
        p.vy += p.gravity * delta;
        p.gfx.x += p.vx * delta;
        p.gfx.y += p.vy * delta;

        // Update lifetime and alpha
        p.life -= delta;
        p.alpha -= p.fade * delta;
        p.gfx.alpha = Math.max(0, p.alpha);

        // Remove particle if life ended, faded out, or went off-screen
        if (p.life <= 0 || p.alpha <= 0 || p.gfx.y > GAME_HEIGHT + 20) {
            particleContainer.removeChild(p.gfx);
            p.gfx.destroy();
            particles.splice(i, 1); // Remove from active array
        }
    }
}
</file_content>

<file_content path="./src//features/Autoplay.js">
import { state, updateState } from '../core/GameState.js'; // Assuming state management
import { setButtonsEnabled, updateAutoplayButtonState as updateBtnState } from '../ui/UIManager.js'; // Assuming UI management
import { startSpin } from '../ui/ButtonHandlers.js'; // Assuming spin initiation
import { winAnimDelayMultiplier } from '../config/animationSettings.js';
import { NUM_PAYLINES } from '../config/paylines.js';
// import { flashElement } from '../ui/Notifications.js'; // Assuming notification handling

/**
 * Handles the logic for the next spin during autoplay.
 * Checks conditions (autoplay active, spins remaining, balance),
 * then schedules the next spin or stops autoplay.
 */
export function handleAutoplayNextSpin() {
    // Stop conditions
    if (!state.isAutoplaying || state.isInFreeSpins || state.isTransitioning) {
        if (state.isAutoplaying) { // Only log/update if it was actually autoplaying
            console.log("Autoplay stopped (condition met: FS/Transition).");
            updateState({ isAutoplaying: false, autoplaySpinsRemaining: 0 });
            updateBtnState(); // Update button appearance
            // updateInfoOverlay(); // Handled by UIManager
            // Enable buttons only if not transitioning into free spins or another state
            setButtonsEnabled(!state.isSpinning && !state.isInFreeSpins && !state.isTransitioning);
        }
        return;
    }

    if (state.autoplaySpinsRemaining > 0) {
        // Check balance before starting the next spin
        const currentTotalBet = state.currentBetPerLine * NUM_PAYLINES; // Recalculate just in case
        if (state.balance < currentTotalBet) {
            console.log("Autoplay stopped: Low balance.");
            updateState({ isAutoplaying: false, autoplaySpinsRemaining: 0 });
            updateBtnState();
            // updateInfoOverlay(); // Handled by UIManager
            setButtonsEnabled(true);
            // flashElement(balanceText, 0xe74c3c); // Needs UIManager reference
            return;
        }

        // Decrement spins and schedule next one
        updateState({ autoplaySpinsRemaining: state.autoplaySpinsRemaining - 1 });
        // updateInfoOverlay(); // Handled by UIManager

        const delay = (state.isTurboMode ? 150 : 600) * winAnimDelayMultiplier;
        updateState({ isTransitioning: true }); // Prevent actions during the short delay

        setTimeout(() => {
            updateState({ isTransitioning: false });
            startSpin(); // Start the next spin
        }, delay);

    } else {
        // Autoplay finished naturally
        console.log("Autoplay finished.");
        updateState({ isAutoplaying: false });
        updateBtnState();
        // updateInfoOverlay(); // Handled by UIManager
        setButtonsEnabled(true); // Re-enable buttons
    }
}

// Note: updateAutoplayButtonState is now assumed to be part of UIManager.js
// If it needs specific logic tied only to autoplay, it could live here,
// but updating button appearance feels like a UI Manager responsibility.
</file_content>

<file_content path="./src//features/PaylineGraphics.js">
import * as PIXI from 'pixi.js';
import { winAnimDelayMultiplier } from '../config/animationSettings.js';
import { REEL_WIDTH, reelAreaX, reelAreaY } from '../config/gameSettings.js'; // Import positioning constants

// Reference to the graphics object (needs initialization)
let winLineGraphics = null;
let winLineFadeTimeout = null;
let winLineFadeInterval = null;

/**
 * Initializes the reference to the win line graphics object.
 * @param {PIXI.Graphics} graphics - The Pixi Graphics object for drawing lines.
 */
export function initPaylineGraphics(graphics) {
    if (!graphics) {
        console.error("PaylineGraphics: Provided graphics object is invalid.");
        return;
    }
    winLineGraphics = graphics;
    // Set initial position based on config (could also be done in Game setup)
    winLineGraphics.x = reelAreaX;
    winLineGraphics.y = reelAreaY;
    console.log("PaylineGraphics initialized with:", winLineGraphics);
}

/**
 * Draws the winning paylines based on the provided win information.
 * Includes fade-in and fade-out animations.
 * @param {Array} winningLinesInfo - Array of objects, each describing a winning line.
 *                                   Expected format: { lineIndex, count, symbols: [symbolObj1, ...] }
 */
export function drawWinLines(winningLinesInfo) {
    if (!winLineGraphics) {
        console.error("PaylineGraphics: Graphics object not initialized.");
        return;
    }
    if (!winningLinesInfo || winningLinesInfo.length === 0) {
        winLineGraphics.clear(); // Clear if no wins
        return;
    }

    // Clear previous animations/timeouts
    if (winLineFadeTimeout) clearTimeout(winLineFadeTimeout);
    if (winLineFadeInterval) clearInterval(winLineFadeInterval);
    winLineGraphics.clear();
    winLineGraphics.alpha = 0; // Start transparent for fade-in

    const lineColors = [ // Define colors for different lines
        0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff, 0xffa500,
        0x800080, 0x008000, 0x800000, 0xadd8e6, 0x90ee90, 0xffb6c1, 0xfaebd7, 0xdda0dd
    ];

    winningLinesInfo.forEach((info) => {
        if (!info.symbols || info.symbols.length < 1) return; // Skip if no symbols recorded

        const lineColor = lineColors[info.lineIndex % lineColors.length];
        winLineGraphics.lineStyle({ width: 5, color: lineColor, alpha: 0.7 });

        let firstValidPoint = true;
        for (let i = 0; i < info.count; i++) {
            const symbolObj = info.symbols[i];
            if (!symbolObj?.parent) { // Check if symbol is still valid and on stage
                console.warn(`PaylineGraphics: Symbol object invalid for line ${info.lineIndex}, index ${i}`);
                continue;
            }

            // Calculate position relative to the winLineGraphics container's origin (reelAreaX, reelAreaY)
            // Assumes symbolObj.parent is the reel container (rc)
            const reelIndex = symbolObj.parent.x / REEL_WIDTH; // Infer reel index from container position
            const symbolCenterX = reelIndex * REEL_WIDTH + REEL_WIDTH / 2;
            const symbolCenterY = symbolObj.y; // y position is relative to the reel container

            if (firstValidPoint) {
                winLineGraphics.moveTo(symbolCenterX, symbolCenterY);
                firstValidPoint = false;
            } else {
                winLineGraphics.lineTo(symbolCenterX, symbolCenterY);
            }
            // Draw circles at symbol centers
            winLineGraphics.drawCircle(symbolCenterX, symbolCenterY, 8).fill({ color: lineColor, alpha: 0.8 });
        }
        if (!firstValidPoint) {
            winLineGraphics.stroke(); // Draw the line segments
        }
    });

    // --- Fade In Animation ---
    let currentAlpha = 0;
    const fadeInDuration = 50 * winAnimDelayMultiplier; // Faster fade-in
    winLineFadeInterval = setInterval(() => {
        currentAlpha += 0.15; // Faster increment
        winLineGraphics.alpha = Math.min(0.8, currentAlpha);
        if (currentAlpha >= 0.8) {
            clearInterval(winLineFadeInterval);
        }
    }, fadeInDuration / (0.8 / 0.15)); // Adjust interval timing

    // --- Fade Out Timer ---
    const displayDuration = 3000 * winAnimDelayMultiplier;
    winLineFadeTimeout = setTimeout(() => {
        if (winLineFadeInterval) clearInterval(winLineFadeInterval); // Ensure fade-in stops

        let fadeOutAlpha = winLineGraphics.alpha;
        const fadeOutDuration = 50 * winAnimDelayMultiplier; // Faster fade-out
        const fadeOutInterval = setInterval(() => {
            fadeOutAlpha -= 0.15; // Faster decrement
            winLineGraphics.alpha = Math.max(0, fadeOutAlpha);
            if (fadeOutAlpha <= 0) {
                clearInterval(fadeOutInterval);
                winLineGraphics.clear(); // Clear graphics after fade out
            }
        }, fadeOutDuration / (fadeOutAlpha / 0.15 + 1)); // Adjust interval timing

    }, displayDuration);
}

/**
 * Clears any active win lines and stops animations.
 */
export function clearWinLines() {
    if (winLineFadeTimeout) clearTimeout(winLineFadeTimeout);
    if (winLineFadeInterval) clearInterval(winLineFadeInterval);
    if (winLineGraphics) {
        winLineGraphics.clear();
        winLineGraphics.alpha = 0;
    }
    winLineFadeTimeout = null;
    winLineFadeInterval = null;
}
</file_content>

<file_content path="./src//utils/helpers.js">
/**
 * Linearly interpolates between two angles, handling wrapping around a range (e.g., 360 degrees or 2*PI radians).
 * @param {number} start - The starting angle.
 * @param {number} end - The target angle.
 * @param {number} t - The interpolation factor (0 to 1).
 * @param {number} range - The full range of the angle (e.g., Math.PI * 2 for radians).
 * @returns {number} The interpolated angle.
 */
export function lerpAngle(start, end, t, range) {
    t = Math.max(0, Math.min(1, t)); // Clamp t between 0 and 1
    let delta = end - start;

    // Adjust delta if the shortest path wraps around the range
    if (Math.abs(delta) > range / 2) {
        delta -= Math.sign(delta) * range;
    }

    let result = start + delta * t;

    // Ensure the result stays within the valid range (e.g., 0 to range)
    return ((result % range) + range) % range;
}

/**
 * Easing function: quadratic ease-out.
 * Starts fast, then decelerates.
 * @param {number} t - Progress ratio (0 to 1).
 * @returns {number} Eased progress ratio.
 */
export const easeOutQuad = (t) => t * (2 - t);

// Add other general utility functions here if needed later.
</file_content>

<file_content path="./src//main.js">
import { Game } from './core/Game.js';

// --- Entry Point ---

// Wait for the DOM to be fully loaded
document.addEventListener('DOMContentLoaded', () => {
    // ID of the container element in index.html where the Pixi canvas will be added
    const gameContainerId = 'game-container'; // Make sure this ID exists in index.html

    // Create and initialize the game instance
    const game = new Game(gameContainerId);
    game.init().catch(err => {
        console.error("Failed to initialize game:", err);
        // Optionally display an error message to the user in the DOM
        const container = document.getElementById(gameContainerId);
        if (container) {
            container.innerHTML = `<p style="color: red; text-align: center; margin-top: 50px;">Error loading game. Please check console.</p>`;
        }
    });
});
</file_content>

<file_content path="./src//styles/main.css">
body {
  margin: 0;
  padding: 0;
  background-color: #1a1a1a;
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
  font-family: "Arial Black", Gadget, sans-serif;
  overflow: hidden;
}
canvas {
  border: 3px solid #b8860b;
  background-color: #2f4f4f;
  box-shadow: 0 0 25px rgba(0, 0, 0, 0.7);
}
.info-overlay {
  position: absolute;
  top: 10px;
  left: 10px;
  background: rgba(0, 0, 0, 0.7);
  color: #fff;
  padding: 5px 10px;
  border-radius: 5px;
  font-size: 14px;
  display: none;
  z-index: 10;
}
</file_content>

